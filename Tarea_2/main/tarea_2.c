#include <float.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "driver/i2c.h"
#include "driver/uart.h"
#include "esp_log.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "math.h"
#include "sdkconfig.h"

#define CONCAT_BYTES(msb, lsb) (((uint16_t)msb << 8) | (uint16_t)lsb)

// for I2C with BMI270
#define I2C_MASTER_SCL_IO         GPIO_NUM_22 // GPIO pin
#define I2C_MASTER_SDA_IO         GPIO_NUM_21 // GPIO pin
#define I2C_MASTER_FREQ_HZ        10000
#define BMI_ESP_SLAVE_ADDR        0x68
#define BME_ESP_SLAVE_ADDR        0x76
#define WRITE_BIT                 0x0
#define READ_BIT                  0x1
#define ACK_CHECK_EN              0x0
#define EXAMPLE_I2C_ACK_CHECK_DIS 0x0
#define ACK_VAL                   0x0
#define NACK_VAL                  0x1

// for UART with python
#define BUF_SIZE (128) // buffer size
#define TXD_PIN 1  // UART TX pin
#define RXD_PIN 3  // UART RX pin
#define UART_NUM UART_NUM_0   // UART port number
#define BAUD_RATE 115200   // Baud rate

#define REDIRECT_LOGS 1 // if redirect ESP log to another UART

esp_err_t ret  = ESP_OK;
esp_err_t ret2 = ESP_OK;

uint16_t val0[6];

// this number helps to avoid triggering the watchdog in for/while loops
int delay_for_watchdog = 10;
float task_delay_ms = 1000;

esp_err_t sensor_init(void) {
    int i2c_master_port = I2C_NUM_0;
    i2c_config_t conf;
    conf.mode = I2C_MODE_MASTER;
    conf.sda_io_num = I2C_MASTER_SDA_IO;
    conf.sda_pullup_en = GPIO_PULLUP_DISABLE;
    conf.scl_io_num = I2C_MASTER_SCL_IO;
    conf.scl_pullup_en = GPIO_PULLUP_DISABLE;
    conf.master.clk_speed = I2C_MASTER_FREQ_HZ;
    conf.clk_flags = I2C_SCLK_SRC_FLAG_FOR_NOMAL;  // 0
    i2c_param_config(i2c_master_port, &conf);
    return i2c_driver_install(i2c_master_port, conf.mode, 0, 0, 0);
}

// ------------ Funciones de comuniaciÃ³n UART -------------- //

// Function for sending things to UART1
static int uart1_printf(const char *str, va_list ap) {
    char *buf;
    vasprintf(&buf, str, ap);
    uart_write_bytes(UART_NUM_1, buf, strlen(buf));
    free(buf);
    return 0;
}

// Setup of UART connections 0 and 1, and try to redirect logs to UART1 if asked
static void uart_setup() {
    uart_config_t uart_config = {
        .baud_rate = 115200,
        .data_bits = UART_DATA_8_BITS,
        .parity = UART_PARITY_DISABLE,
        .stop_bits = UART_STOP_BITS_1,
        .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,
    };

    uart_param_config(UART_NUM_0, &uart_config);
    uart_param_config(UART_NUM_1, &uart_config);
    uart_driver_install(UART_NUM_0, BUF_SIZE * 2, 0, 0, NULL, 0);
    uart_driver_install(UART_NUM_1, BUF_SIZE * 2, 0, 0, NULL, 0);

    // Redirect ESP log to UART1
    if (REDIRECT_LOGS) {
        esp_log_set_vprintf(uart1_printf);
    }
}

// Read UART_num for input with timeout of 1 sec
int serial_read(char *buffer, int size) {
    int len = uart_read_bytes(UART_NUM, (uint8_t*)buffer, size, pdMS_TO_TICKS(1000));
    return len;
}

// ------------ Funciones para datos -------------- //

/**
 * @brief Funcion que calcula la FFT de un arreglo y guarda el resultado inplace
 *
 * @param array Arreglo de elementos sobre los que se quiere calcular la FFT
 * @param size Tamano del arreglo
 * @param array_re Direccion del arreglo donde se guardara la parte real. Debe ser de tamano size
 * @param array_im Direccion del arreglo donde se guardara la parte imaginaria. Debe ser de tamano size
 */
void calcularFFT(float *array, int size, float *array_re, float *array_im) {
    for (int k = 0; k < size; k++) {
        float real = 0;
        float imag = 0;

        for (int n = 0; n < size; n++) {
            float angulo = 2 * M_PI * k * n / size;
            float cos_angulo = cos(angulo);
            float sin_angulo = -sin(angulo);

            real += array[n] * cos_angulo;
            imag += array[n] * sin_angulo;
        }
        real /= size;
        imag /= size;
        array_re[k] = real;
        array_im[k] = imag;

        // to avoid watchdog
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }
}

// comparator function for qsort
int compare(const void *a, const void *b) {
    float fa = *(const float*) a;
    float fb = *(const float*) b;
    return (fa < fb) - (fa > fb);
}

// this function saves the top 5 values of an array in another array, this function modifies the original array
void save_top_5(float *array, int size, float *top_5) {
    qsort(array, size, sizeof(float), compare);
    for (int i = 0; i < 5 && i < size; i++) {
        top_5[i] = array[i];
    }
}

// ------------ Funciones de lecutra/escritura por I2C -------------- //
esp_err_t bmi_i2c_read(i2c_port_t i2c_num, uint8_t *data_addres, uint8_t *data_rd, size_t size) {
    if (size == 0) {
        return ESP_OK;
    }
    i2c_cmd_handle_t cmd = i2c_cmd_link_create();
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, (BMI_ESP_SLAVE_ADDR << 1) | WRITE_BIT, ACK_CHECK_EN);
    i2c_master_write(cmd, data_addres, size, ACK_CHECK_EN);
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, (BMI_ESP_SLAVE_ADDR << 1) | READ_BIT, ACK_CHECK_EN);
    if (size > 1) {
        i2c_master_read(cmd, data_rd, size - 1, ACK_VAL);
    }
    i2c_master_read_byte(cmd, data_rd + size - 1, NACK_VAL);
    i2c_master_stop(cmd);
    ret = i2c_master_cmd_begin(i2c_num, cmd, 1000 / portTICK_PERIOD_MS);
    i2c_cmd_link_delete(cmd);
    return ret;
}

esp_err_t bmi_i2c_write(i2c_port_t i2c_num, uint8_t *data_addres, uint8_t *data_wr, size_t size) {
    uint8_t size1 = 1;
    i2c_cmd_handle_t cmd = i2c_cmd_link_create();
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, (BMI_ESP_SLAVE_ADDR << 1) | WRITE_BIT, ACK_CHECK_EN);
    i2c_master_write(cmd, data_addres, size1, ACK_CHECK_EN);
    i2c_master_write(cmd, data_wr, size, ACK_CHECK_EN);
    i2c_master_stop(cmd);
    esp_err_t ret = i2c_master_cmd_begin(i2c_num, cmd, 1000 / portTICK_PERIOD_MS);
    i2c_cmd_link_delete(cmd);
    return ret;
}

esp_err_t bme_i2c_read(i2c_port_t i2c_num, uint8_t *data_addres, uint8_t *data_rd, size_t size) {
    if (size == 0) {
        return ESP_OK;
    }
    i2c_cmd_handle_t cmd = i2c_cmd_link_create();
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, (BME_ESP_SLAVE_ADDR << 1) | WRITE_BIT, ACK_CHECK_EN);
    i2c_master_write(cmd, data_addres, size, ACK_CHECK_EN);
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, (BME_ESP_SLAVE_ADDR << 1) | READ_BIT, ACK_CHECK_EN);
    if (size > 1) {
        i2c_master_read(cmd, data_rd, size - 1, ACK_VAL);
    }
    i2c_master_read_byte(cmd, data_rd + size - 1, NACK_VAL);
    i2c_master_stop(cmd);
    esp_err_t ret = i2c_master_cmd_begin(i2c_num, cmd, 1000 / portTICK_PERIOD_MS);
    i2c_cmd_link_delete(cmd);
    return ret;
}

esp_err_t bme_i2c_write(i2c_port_t i2c_num, uint8_t *data_addres, uint8_t *data_wr, size_t size) {
    uint8_t size1 = 1;
    i2c_cmd_handle_t cmd = i2c_cmd_link_create();
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, (BME_ESP_SLAVE_ADDR << 1) | WRITE_BIT, ACK_CHECK_EN);
    i2c_master_write(cmd, data_addres, size1, ACK_CHECK_EN);
    i2c_master_write(cmd, data_wr, size, ACK_CHECK_EN);
    i2c_master_stop(cmd);
    esp_err_t ret = i2c_master_cmd_begin(i2c_num, cmd, 1000 / portTICK_PERIOD_MS);
    i2c_cmd_link_delete(cmd);
    return ret;
}

// ----------- BMI 270 ------------- //
const uint8_t bmi270_config_file[] = {
    0xc8, 0x2e, 0x00, 0x2e, 0x80, 0x2e, 0x3d, 0xb1, 0xc8, 0x2e, 0x00, 0x2e, 0x80, 0x2e, 0x91, 0x03, 0x80, 0x2e, 0xbc,
    0xb0, 0x80, 0x2e, 0xa3, 0x03, 0xc8, 0x2e, 0x00, 0x2e, 0x80, 0x2e, 0x00, 0xb0, 0x50, 0x30, 0x21, 0x2e, 0x59, 0xf5,
    0x10, 0x30, 0x21, 0x2e, 0x6a, 0xf5, 0x80, 0x2e, 0x3b, 0x03, 0x00, 0x00, 0x00, 0x00, 0x08, 0x19, 0x01, 0x00, 0x22,
    0x00, 0x75, 0x00, 0x00, 0x10, 0x00, 0x10, 0xd1, 0x00, 0xb3, 0x43, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
    0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00,
    0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e,
    0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80,
    0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
    0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00,
    0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e,
    0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80,
    0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
    0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0xe0, 0x5f, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x92, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x19, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05,
    0xe0, 0xaa, 0x38, 0x05, 0xe0, 0x90, 0x30, 0xfa, 0x00, 0x96, 0x00, 0x4b, 0x09, 0x11, 0x00, 0x11, 0x00, 0x02, 0x00,
    0x2d, 0x01, 0xd4, 0x7b, 0x3b, 0x01, 0xdb, 0x7a, 0x04, 0x00, 0x3f, 0x7b, 0xcd, 0x6c, 0xc3, 0x04, 0x85, 0x09, 0xc3,
    0x04, 0xec, 0xe6, 0x0c, 0x46, 0x01, 0x00, 0x27, 0x00, 0x19, 0x00, 0x96, 0x00, 0xa0, 0x00, 0x01, 0x00, 0x0c, 0x00,
    0xf0, 0x3c, 0x00, 0x01, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x32, 0x00, 0x05, 0x00, 0xee,
    0x06, 0x04, 0x00, 0xc8, 0x00, 0x00, 0x00, 0x04, 0x00, 0xa8, 0x05, 0xee, 0x06, 0x00, 0x04, 0xbc, 0x02, 0xb3, 0x00,
    0x85, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xb4, 0x00, 0x01, 0x00, 0xb9, 0x00, 0x01, 0x00, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x00, 0x80, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x2e, 0x00, 0xc1, 0xfd, 0x2d, 0xde,
    0x00, 0xeb, 0x00, 0xda, 0x00, 0x00, 0x0c, 0xff, 0x0f, 0x00, 0x04, 0xc0, 0x00, 0x5b, 0xf5, 0xc9, 0x01, 0x1e, 0xf2,
    0x80, 0x00, 0x3f, 0xff, 0x19, 0xf4, 0x58, 0xf5, 0x66, 0xf5, 0x64, 0xf5, 0xc0, 0xf1, 0xf0, 0x00, 0xe0, 0x00, 0xcd,
    0x01, 0xd3, 0x01, 0xdb, 0x01, 0xff, 0x7f, 0xff, 0x01, 0xe4, 0x00, 0x74, 0xf7, 0xf3, 0x00, 0xfa, 0x00, 0xff, 0x3f,
    0xca, 0x03, 0x6c, 0x38, 0x56, 0xfe, 0x44, 0xfd, 0xbc, 0x02, 0xf9, 0x06, 0x00, 0xfc, 0x12, 0x02, 0xae, 0x01, 0x58,
    0xfa, 0x9a, 0xfd, 0x77, 0x05, 0xbb, 0x02, 0x96, 0x01, 0x95, 0x01, 0x7f, 0x01, 0x82, 0x01, 0x89, 0x01, 0x87, 0x01,
    0x88, 0x01, 0x8a, 0x01, 0x8c, 0x01, 0x8f, 0x01, 0x8d, 0x01, 0x92, 0x01, 0x91, 0x01, 0xdd, 0x00, 0x9f, 0x01, 0x7e,
    0x01, 0xdb, 0x00, 0xb6, 0x01, 0x70, 0x69, 0x26, 0xd3, 0x9c, 0x07, 0x1f, 0x05, 0x9d, 0x00, 0x00, 0x08, 0xbc, 0x05,
    0x37, 0xfa, 0xa2, 0x01, 0xaa, 0x01, 0xa1, 0x01, 0xa8, 0x01, 0xa0, 0x01, 0xa8, 0x05, 0xb4, 0x01, 0xb4, 0x01, 0xce,
    0x00, 0xd0, 0x00, 0xfc, 0x00, 0xc5, 0x01, 0xff, 0xfb, 0xb1, 0x00, 0x00, 0x38, 0x00, 0x30, 0xfd, 0xf5, 0xfc, 0xf5,
    0xcd, 0x01, 0xa0, 0x00, 0x5f, 0xff, 0x00, 0x40, 0xff, 0x00, 0x00, 0x80, 0x6d, 0x0f, 0xeb, 0x00, 0x7f, 0xff, 0xc2,
    0xf5, 0x68, 0xf7, 0xb3, 0xf1, 0x67, 0x0f, 0x5b, 0x0f, 0x61, 0x0f, 0x80, 0x0f, 0x58, 0xf7, 0x5b, 0xf7, 0x83, 0x0f,
    0x86, 0x00, 0x72, 0x0f, 0x85, 0x0f, 0xc6, 0xf1, 0x7f, 0x0f, 0x6c, 0xf7, 0x00, 0xe0, 0x00, 0xff, 0xd1, 0xf5, 0x87,
    0x0f, 0x8a, 0x0f, 0xff, 0x03, 0xf0, 0x3f, 0x8b, 0x00, 0x8e, 0x00, 0x90, 0x00, 0xb9, 0x00, 0x2d, 0xf5, 0xca, 0xf5,
    0xcb, 0x01, 0x20, 0xf2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x50, 0x98, 0x2e,
    0xd7, 0x0e, 0x50, 0x32, 0x98, 0x2e, 0xfa, 0x03, 0x00, 0x30, 0xf0, 0x7f, 0x00, 0x2e, 0x00, 0x2e, 0xd0, 0x2e, 0x00,
    0x2e, 0x01, 0x80, 0x08, 0xa2, 0xfb, 0x2f, 0x98, 0x2e, 0xba, 0x03, 0x21, 0x2e, 0x19, 0x00, 0x01, 0x2e, 0xee, 0x00,
    0x00, 0xb2, 0x07, 0x2f, 0x01, 0x2e, 0x19, 0x00, 0x00, 0xb2, 0x03, 0x2f, 0x01, 0x50, 0x03, 0x52, 0x98, 0x2e, 0x07,
    0xcc, 0x01, 0x2e, 0xdd, 0x00, 0x00, 0xb2, 0x27, 0x2f, 0x05, 0x2e, 0x8a, 0x00, 0x05, 0x52, 0x98, 0x2e, 0xc7, 0xc1,
    0x03, 0x2e, 0xe9, 0x00, 0x40, 0xb2, 0xf0, 0x7f, 0x08, 0x2f, 0x01, 0x2e, 0x19, 0x00, 0x00, 0xb2, 0x04, 0x2f, 0x00,
    0x30, 0x21, 0x2e, 0xe9, 0x00, 0x98, 0x2e, 0xb4, 0xb1, 0x01, 0x2e, 0x18, 0x00, 0x00, 0xb2, 0x10, 0x2f, 0x05, 0x50,
    0x98, 0x2e, 0x4d, 0xc3, 0x05, 0x50, 0x98, 0x2e, 0x5a, 0xc7, 0x98, 0x2e, 0xf9, 0xb4, 0x98, 0x2e, 0x54, 0xb2, 0x98,
    0x2e, 0x67, 0xb6, 0x98, 0x2e, 0x17, 0xb2, 0x10, 0x30, 0x21, 0x2e, 0x77, 0x00, 0x01, 0x2e, 0xef, 0x00, 0x00, 0xb2,
    0x04, 0x2f, 0x98, 0x2e, 0x7a, 0xb7, 0x00, 0x30, 0x21, 0x2e, 0xef, 0x00, 0x01, 0x2e, 0xd4, 0x00, 0x04, 0xae, 0x0b,
    0x2f, 0x01, 0x2e, 0xdd, 0x00, 0x00, 0xb2, 0x07, 0x2f, 0x05, 0x52, 0x98, 0x2e, 0x8e, 0x0e, 0x00, 0xb2, 0x02, 0x2f,
    0x10, 0x30, 0x21, 0x2e, 0x7d, 0x00, 0x01, 0x2e, 0x7d, 0x00, 0x00, 0x90, 0x90, 0x2e, 0xf1, 0x02, 0x01, 0x2e, 0xd7,
    0x00, 0x00, 0xb2, 0x04, 0x2f, 0x98, 0x2e, 0x2f, 0x0e, 0x00, 0x30, 0x21, 0x2e, 0x7b, 0x00, 0x01, 0x2e, 0x7b, 0x00,
    0x00, 0xb2, 0x12, 0x2f, 0x01, 0x2e, 0xd4, 0x00, 0x00, 0x90, 0x02, 0x2f, 0x98, 0x2e, 0x1f, 0x0e, 0x09, 0x2d, 0x98,
    0x2e, 0x81, 0x0d, 0x01, 0x2e, 0xd4, 0x00, 0x04, 0x90, 0x02, 0x2f, 0x50, 0x32, 0x98, 0x2e, 0xfa, 0x03, 0x00, 0x30,
    0x21, 0x2e, 0x7b, 0x00, 0x01, 0x2e, 0x7c, 0x00, 0x00, 0xb2, 0x90, 0x2e, 0x09, 0x03, 0x01, 0x2e, 0x7c, 0x00, 0x01,
    0x31, 0x01, 0x08, 0x00, 0xb2, 0x04, 0x2f, 0x98, 0x2e, 0x47, 0xcb, 0x10, 0x30, 0x21, 0x2e, 0x77, 0x00, 0x81, 0x30,
    0x01, 0x2e, 0x7c, 0x00, 0x01, 0x08, 0x00, 0xb2, 0x61, 0x2f, 0x03, 0x2e, 0x89, 0x00, 0x01, 0x2e, 0xd4, 0x00, 0x98,
    0xbc, 0x98, 0xb8, 0x05, 0xb2, 0x0f, 0x58, 0x23, 0x2f, 0x07, 0x90, 0x09, 0x54, 0x00, 0x30, 0x37, 0x2f, 0x15, 0x41,
    0x04, 0x41, 0xdc, 0xbe, 0x44, 0xbe, 0xdc, 0xba, 0x2c, 0x01, 0x61, 0x00, 0x0f, 0x56, 0x4a, 0x0f, 0x0c, 0x2f, 0xd1,
    0x42, 0x94, 0xb8, 0xc1, 0x42, 0x11, 0x30, 0x05, 0x2e, 0x6a, 0xf7, 0x2c, 0xbd, 0x2f, 0xb9, 0x80, 0xb2, 0x08, 0x22,
    0x98, 0x2e, 0xc3, 0xb7, 0x21, 0x2d, 0x61, 0x30, 0x23, 0x2e, 0xd4, 0x00, 0x98, 0x2e, 0xc3, 0xb7, 0x00, 0x30, 0x21,
    0x2e, 0x5a, 0xf5, 0x18, 0x2d, 0xe1, 0x7f, 0x50, 0x30, 0x98, 0x2e, 0xfa, 0x03, 0x0f, 0x52, 0x07, 0x50, 0x50, 0x42,
    0x70, 0x30, 0x0d, 0x54, 0x42, 0x42, 0x7e, 0x82, 0xe2, 0x6f, 0x80, 0xb2, 0x42, 0x42, 0x05, 0x2f, 0x21, 0x2e, 0xd4,
    0x00, 0x10, 0x30, 0x98, 0x2e, 0xc3, 0xb7, 0x03, 0x2d, 0x60, 0x30, 0x21, 0x2e, 0xd4, 0x00, 0x01, 0x2e, 0xd4, 0x00,
    0x06, 0x90, 0x18, 0x2f, 0x01, 0x2e, 0x76, 0x00, 0x0b, 0x54, 0x07, 0x52, 0xe0, 0x7f, 0x98, 0x2e, 0x7a, 0xc1, 0xe1,
    0x6f, 0x08, 0x1a, 0x40, 0x30, 0x08, 0x2f, 0x21, 0x2e, 0xd4, 0x00, 0x20, 0x30, 0x98, 0x2e, 0xaf, 0xb7, 0x50, 0x32,
    0x98, 0x2e, 0xfa, 0x03, 0x05, 0x2d, 0x98, 0x2e, 0x38, 0x0e, 0x00, 0x30, 0x21, 0x2e, 0xd4, 0x00, 0x00, 0x30, 0x21,
    0x2e, 0x7c, 0x00, 0x18, 0x2d, 0x01, 0x2e, 0xd4, 0x00, 0x03, 0xaa, 0x01, 0x2f, 0x98, 0x2e, 0x45, 0x0e, 0x01, 0x2e,
    0xd4, 0x00, 0x3f, 0x80, 0x03, 0xa2, 0x01, 0x2f, 0x00, 0x2e, 0x02, 0x2d, 0x98, 0x2e, 0x5b, 0x0e, 0x30, 0x30, 0x98,
    0x2e, 0xce, 0xb7, 0x00, 0x30, 0x21, 0x2e, 0x7d, 0x00, 0x50, 0x32, 0x98, 0x2e, 0xfa, 0x03, 0x01, 0x2e, 0x77, 0x00,
    0x00, 0xb2, 0x24, 0x2f, 0x98, 0x2e, 0xf5, 0xcb, 0x03, 0x2e, 0xd5, 0x00, 0x11, 0x54, 0x01, 0x0a, 0xbc, 0x84, 0x83,
    0x86, 0x21, 0x2e, 0xc9, 0x01, 0xe0, 0x40, 0x13, 0x52, 0xc4, 0x40, 0x82, 0x40, 0xa8, 0xb9, 0x52, 0x42, 0x43, 0xbe,
    0x53, 0x42, 0x04, 0x0a, 0x50, 0x42, 0xe1, 0x7f, 0xf0, 0x31, 0x41, 0x40, 0xf2, 0x6f, 0x25, 0xbd, 0x08, 0x08, 0x02,
    0x0a, 0xd0, 0x7f, 0x98, 0x2e, 0xa8, 0xcf, 0x06, 0xbc, 0xd1, 0x6f, 0xe2, 0x6f, 0x08, 0x0a, 0x80, 0x42, 0x98, 0x2e,
    0x58, 0xb7, 0x00, 0x30, 0x21, 0x2e, 0xee, 0x00, 0x21, 0x2e, 0x77, 0x00, 0x21, 0x2e, 0xdd, 0x00, 0x80, 0x2e, 0xf4,
    0x01, 0x1a, 0x24, 0x22, 0x00, 0x80, 0x2e, 0xec, 0x01, 0x10, 0x50, 0xfb, 0x7f, 0x98, 0x2e, 0xf3, 0x03, 0x57, 0x50,
    0xfb, 0x6f, 0x01, 0x30, 0x71, 0x54, 0x11, 0x42, 0x42, 0x0e, 0xfc, 0x2f, 0xc0, 0x2e, 0x01, 0x42, 0xf0, 0x5f, 0x80,
    0x2e, 0x00, 0xc1, 0xfd, 0x2d, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9a, 0x01,
    0x34, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x20, 0x50, 0xe7, 0x7f, 0xf6, 0x7f, 0x06, 0x32, 0x0f, 0x2e, 0x61, 0xf5, 0xfe, 0x09, 0xc0, 0xb3, 0x04,
    0x2f, 0x17, 0x30, 0x2f, 0x2e, 0xef, 0x00, 0x2d, 0x2e, 0x61, 0xf5, 0xf6, 0x6f, 0xe7, 0x6f, 0xe0, 0x5f, 0xc8, 0x2e,
    0x20, 0x50, 0xe7, 0x7f, 0xf6, 0x7f, 0x46, 0x30, 0x0f, 0x2e, 0xa4, 0xf1, 0xbe, 0x09, 0x80, 0xb3, 0x06, 0x2f, 0x0d,
    0x2e, 0xd4, 0x00, 0x84, 0xaf, 0x02, 0x2f, 0x16, 0x30, 0x2d, 0x2e, 0x7b, 0x00, 0x86, 0x30, 0x2d, 0x2e, 0x60, 0xf5,
    0xf6, 0x6f, 0xe7, 0x6f, 0xe0, 0x5f, 0xc8, 0x2e, 0x01, 0x2e, 0x77, 0xf7, 0x09, 0xbc, 0x0f, 0xb8, 0x00, 0xb2, 0x10,
    0x50, 0xfb, 0x7f, 0x10, 0x30, 0x0b, 0x2f, 0x03, 0x2e, 0x8a, 0x00, 0x96, 0xbc, 0x9f, 0xb8, 0x40, 0xb2, 0x05, 0x2f,
    0x03, 0x2e, 0x68, 0xf7, 0x9e, 0xbc, 0x9f, 0xb8, 0x40, 0xb2, 0x07, 0x2f, 0x03, 0x2e, 0x7e, 0x00, 0x41, 0x90, 0x01,
    0x2f, 0x98, 0x2e, 0xdc, 0x03, 0x03, 0x2c, 0x00, 0x30, 0x21, 0x2e, 0x7e, 0x00, 0xfb, 0x6f, 0xf0, 0x5f, 0xb8, 0x2e,
    0x20, 0x50, 0xe0, 0x7f, 0xfb, 0x7f, 0x00, 0x2e, 0x27, 0x50, 0x98, 0x2e, 0x3b, 0xc8, 0x29, 0x50, 0x98, 0x2e, 0xa7,
    0xc8, 0x01, 0x50, 0x98, 0x2e, 0x55, 0xcc, 0xe1, 0x6f, 0x2b, 0x50, 0x98, 0x2e, 0xe0, 0xc9, 0xfb, 0x6f, 0x00, 0x30,
    0xe0, 0x5f, 0x21, 0x2e, 0x7e, 0x00, 0xb8, 0x2e, 0x73, 0x50, 0x01, 0x30, 0x57, 0x54, 0x11, 0x42, 0x42, 0x0e, 0xfc,
    0x2f, 0xb8, 0x2e, 0x21, 0x2e, 0x59, 0xf5, 0x10, 0x30, 0xc0, 0x2e, 0x21, 0x2e, 0x4a, 0xf1, 0x90, 0x50, 0xf7, 0x7f,
    0xe6, 0x7f, 0xd5, 0x7f, 0xc4, 0x7f, 0xb3, 0x7f, 0xa1, 0x7f, 0x90, 0x7f, 0x82, 0x7f, 0x7b, 0x7f, 0x98, 0x2e, 0x35,
    0xb7, 0x00, 0xb2, 0x90, 0x2e, 0x97, 0xb0, 0x03, 0x2e, 0x8f, 0x00, 0x07, 0x2e, 0x91, 0x00, 0x05, 0x2e, 0xb1, 0x00,
    0x3f, 0xba, 0x9f, 0xb8, 0x01, 0x2e, 0xb1, 0x00, 0xa3, 0xbd, 0x4c, 0x0a, 0x05, 0x2e, 0xb1, 0x00, 0x04, 0xbe, 0xbf,
    0xb9, 0xcb, 0x0a, 0x4f, 0xba, 0x22, 0xbd, 0x01, 0x2e, 0xb3, 0x00, 0xdc, 0x0a, 0x2f, 0xb9, 0x03, 0x2e, 0xb8, 0x00,
    0x0a, 0xbe, 0x9a, 0x0a, 0xcf, 0xb9, 0x9b, 0xbc, 0x01, 0x2e, 0x97, 0x00, 0x9f, 0xb8, 0x93, 0x0a, 0x0f, 0xbc, 0x91,
    0x0a, 0x0f, 0xb8, 0x90, 0x0a, 0x25, 0x2e, 0x18, 0x00, 0x05, 0x2e, 0xc1, 0xf5, 0x2e, 0xbd, 0x2e, 0xb9, 0x01, 0x2e,
    0x19, 0x00, 0x31, 0x30, 0x8a, 0x04, 0x00, 0x90, 0x07, 0x2f, 0x01, 0x2e, 0xd4, 0x00, 0x04, 0xa2, 0x03, 0x2f, 0x01,
    0x2e, 0x18, 0x00, 0x00, 0xb2, 0x0c, 0x2f, 0x19, 0x50, 0x05, 0x52, 0x98, 0x2e, 0x4d, 0xb7, 0x05, 0x2e, 0x78, 0x00,
    0x80, 0x90, 0x10, 0x30, 0x01, 0x2f, 0x21, 0x2e, 0x78, 0x00, 0x25, 0x2e, 0xdd, 0x00, 0x98, 0x2e, 0x3e, 0xb7, 0x00,
    0xb2, 0x02, 0x30, 0x01, 0x30, 0x04, 0x2f, 0x01, 0x2e, 0x19, 0x00, 0x00, 0xb2, 0x00, 0x2f, 0x21, 0x30, 0x01, 0x2e,
    0xea, 0x00, 0x08, 0x1a, 0x0e, 0x2f, 0x23, 0x2e, 0xea, 0x00, 0x33, 0x30, 0x1b, 0x50, 0x0b, 0x09, 0x01, 0x40, 0x17,
    0x56, 0x46, 0xbe, 0x4b, 0x08, 0x4c, 0x0a, 0x01, 0x42, 0x0a, 0x80, 0x15, 0x52, 0x01, 0x42, 0x00, 0x2e, 0x01, 0x2e,
    0x18, 0x00, 0x00, 0xb2, 0x1f, 0x2f, 0x03, 0x2e, 0xc0, 0xf5, 0xf0, 0x30, 0x48, 0x08, 0x47, 0xaa, 0x74, 0x30, 0x07,
    0x2e, 0x7a, 0x00, 0x61, 0x22, 0x4b, 0x1a, 0x05, 0x2f, 0x07, 0x2e, 0x66, 0xf5, 0xbf, 0xbd, 0xbf, 0xb9, 0xc0, 0x90,
    0x0b, 0x2f, 0x1d, 0x56, 0x2b, 0x30, 0xd2, 0x42, 0xdb, 0x42, 0x01, 0x04, 0xc2, 0x42, 0x04, 0xbd, 0xfe, 0x80, 0x81,
    0x84, 0x23, 0x2e, 0x7a, 0x00, 0x02, 0x42, 0x02, 0x32, 0x25, 0x2e, 0x62, 0xf5, 0x05, 0x2e, 0xd6, 0x00, 0x81, 0x84,
    0x25, 0x2e, 0xd6, 0x00, 0x02, 0x31, 0x25, 0x2e, 0x60, 0xf5, 0x05, 0x2e, 0x8a, 0x00, 0x0b, 0x50, 0x90, 0x08, 0x80,
    0xb2, 0x0b, 0x2f, 0x05, 0x2e, 0xca, 0xf5, 0xf0, 0x3e, 0x90, 0x08, 0x25, 0x2e, 0xca, 0xf5, 0x05, 0x2e, 0x59, 0xf5,
    0xe0, 0x3f, 0x90, 0x08, 0x25, 0x2e, 0x59, 0xf5, 0x90, 0x6f, 0xa1, 0x6f, 0xb3, 0x6f, 0xc4, 0x6f, 0xd5, 0x6f, 0xe6,
    0x6f, 0xf7, 0x6f, 0x7b, 0x6f, 0x82, 0x6f, 0x70, 0x5f, 0xc8, 0x2e, 0xc0, 0x50, 0x90, 0x7f, 0xe5, 0x7f, 0xd4, 0x7f,
    0xc3, 0x7f, 0xb1, 0x7f, 0xa2, 0x7f, 0x87, 0x7f, 0xf6, 0x7f, 0x7b, 0x7f, 0x00, 0x2e, 0x01, 0x2e, 0x60, 0xf5, 0x60,
    0x7f, 0x98, 0x2e, 0x35, 0xb7, 0x02, 0x30, 0x63, 0x6f, 0x15, 0x52, 0x50, 0x7f, 0x62, 0x7f, 0x5a, 0x2c, 0x02, 0x32,
    0x1a, 0x09, 0x00, 0xb3, 0x14, 0x2f, 0x00, 0xb2, 0x03, 0x2f, 0x09, 0x2e, 0x18, 0x00, 0x00, 0x91, 0x0c, 0x2f, 0x43,
    0x7f, 0x98, 0x2e, 0x97, 0xb7, 0x1f, 0x50, 0x02, 0x8a, 0x02, 0x32, 0x04, 0x30, 0x25, 0x2e, 0x64, 0xf5, 0x15, 0x52,
    0x50, 0x6f, 0x43, 0x6f, 0x44, 0x43, 0x25, 0x2e, 0x60, 0xf5, 0xd9, 0x08, 0xc0, 0xb2, 0x36, 0x2f, 0x98, 0x2e, 0x3e,
    0xb7, 0x00, 0xb2, 0x06, 0x2f, 0x01, 0x2e, 0x19, 0x00, 0x00, 0xb2, 0x02, 0x2f, 0x50, 0x6f, 0x00, 0x90, 0x0a, 0x2f,
    0x01, 0x2e, 0x79, 0x00, 0x00, 0x90, 0x19, 0x2f, 0x10, 0x30, 0x21, 0x2e, 0x79, 0x00, 0x00, 0x30, 0x98, 0x2e, 0xdc,
    0x03, 0x13, 0x2d, 0x01, 0x2e, 0xc3, 0xf5, 0x0c, 0xbc, 0x0f, 0xb8, 0x12, 0x30, 0x10, 0x04, 0x03, 0xb0, 0x26, 0x25,
    0x21, 0x50, 0x03, 0x52, 0x98, 0x2e, 0x4d, 0xb7, 0x10, 0x30, 0x21, 0x2e, 0xee, 0x00, 0x02, 0x30, 0x60, 0x7f, 0x25,
    0x2e, 0x79, 0x00, 0x60, 0x6f, 0x00, 0x90, 0x05, 0x2f, 0x00, 0x30, 0x21, 0x2e, 0xea, 0x00, 0x15, 0x50, 0x21, 0x2e,
    0x64, 0xf5, 0x15, 0x52, 0x23, 0x2e, 0x60, 0xf5, 0x02, 0x32, 0x50, 0x6f, 0x00, 0x90, 0x02, 0x2f, 0x03, 0x30, 0x27,
    0x2e, 0x78, 0x00, 0x07, 0x2e, 0x60, 0xf5, 0x1a, 0x09, 0x00, 0x91, 0xa3, 0x2f, 0x19, 0x09, 0x00, 0x91, 0xa0, 0x2f,
    0x90, 0x6f, 0xa2, 0x6f, 0xb1, 0x6f, 0xc3, 0x6f, 0xd4, 0x6f, 0xe5, 0x6f, 0x7b, 0x6f, 0xf6, 0x6f, 0x87, 0x6f, 0x40,
    0x5f, 0xc8, 0x2e, 0xc0, 0x50, 0xe7, 0x7f, 0xf6, 0x7f, 0x26, 0x30, 0x0f, 0x2e, 0x61, 0xf5, 0x2f, 0x2e, 0x7c, 0x00,
    0x0f, 0x2e, 0x7c, 0x00, 0xbe, 0x09, 0xa2, 0x7f, 0x80, 0x7f, 0x80, 0xb3, 0xd5, 0x7f, 0xc4, 0x7f, 0xb3, 0x7f, 0x91,
    0x7f, 0x7b, 0x7f, 0x0b, 0x2f, 0x23, 0x50, 0x1a, 0x25, 0x12, 0x40, 0x42, 0x7f, 0x74, 0x82, 0x12, 0x40, 0x52, 0x7f,
    0x00, 0x2e, 0x00, 0x40, 0x60, 0x7f, 0x98, 0x2e, 0x6a, 0xd6, 0x81, 0x30, 0x01, 0x2e, 0x7c, 0x00, 0x01, 0x08, 0x00,
    0xb2, 0x42, 0x2f, 0x03, 0x2e, 0x89, 0x00, 0x01, 0x2e, 0x89, 0x00, 0x97, 0xbc, 0x06, 0xbc, 0x9f, 0xb8, 0x0f, 0xb8,
    0x00, 0x90, 0x23, 0x2e, 0xd8, 0x00, 0x10, 0x30, 0x01, 0x30, 0x2a, 0x2f, 0x03, 0x2e, 0xd4, 0x00, 0x44, 0xb2, 0x05,
    0x2f, 0x47, 0xb2, 0x00, 0x30, 0x2d, 0x2f, 0x21, 0x2e, 0x7c, 0x00, 0x2b, 0x2d, 0x03, 0x2e, 0xfd, 0xf5, 0x9e, 0xbc,
    0x9f, 0xb8, 0x40, 0x90, 0x14, 0x2f, 0x03, 0x2e, 0xfc, 0xf5, 0x99, 0xbc, 0x9f, 0xb8, 0x40, 0x90, 0x0e, 0x2f, 0x03,
    0x2e, 0x49, 0xf1, 0x25, 0x54, 0x4a, 0x08, 0x40, 0x90, 0x08, 0x2f, 0x98, 0x2e, 0x35, 0xb7, 0x00, 0xb2, 0x10, 0x30,
    0x03, 0x2f, 0x50, 0x30, 0x21, 0x2e, 0xd4, 0x00, 0x10, 0x2d, 0x98, 0x2e, 0xaf, 0xb7, 0x00, 0x30, 0x21, 0x2e, 0x7c,
    0x00, 0x0a, 0x2d, 0x05, 0x2e, 0x69, 0xf7, 0x2d, 0xbd, 0x2f, 0xb9, 0x80, 0xb2, 0x01, 0x2f, 0x21, 0x2e, 0x7d, 0x00,
    0x23, 0x2e, 0x7c, 0x00, 0xe0, 0x31, 0x21, 0x2e, 0x61, 0xf5, 0xf6, 0x6f, 0xe7, 0x6f, 0x80, 0x6f, 0xa2, 0x6f, 0xb3,
    0x6f, 0xc4, 0x6f, 0xd5, 0x6f, 0x7b, 0x6f, 0x91, 0x6f, 0x40, 0x5f, 0xc8, 0x2e, 0x60, 0x51, 0x0a, 0x25, 0x36, 0x88,
    0xf4, 0x7f, 0xeb, 0x7f, 0x00, 0x32, 0x31, 0x52, 0x32, 0x30, 0x13, 0x30, 0x98, 0x2e, 0x15, 0xcb, 0x0a, 0x25, 0x33,
    0x84, 0xd2, 0x7f, 0x43, 0x30, 0x05, 0x50, 0x2d, 0x52, 0x98, 0x2e, 0x95, 0xc1, 0xd2, 0x6f, 0x27, 0x52, 0x98, 0x2e,
    0xd7, 0xc7, 0x2a, 0x25, 0xb0, 0x86, 0xc0, 0x7f, 0xd3, 0x7f, 0xaf, 0x84, 0x29, 0x50, 0xf1, 0x6f, 0x98, 0x2e, 0x4d,
    0xc8, 0x2a, 0x25, 0xae, 0x8a, 0xaa, 0x88, 0xf2, 0x6e, 0x2b, 0x50, 0xc1, 0x6f, 0xd3, 0x6f, 0xf4, 0x7f, 0x98, 0x2e,
    0xb6, 0xc8, 0xe0, 0x6e, 0x00, 0xb2, 0x32, 0x2f, 0x33, 0x54, 0x83, 0x86, 0xf1, 0x6f, 0xc3, 0x7f, 0x04, 0x30, 0x30,
    0x30, 0xf4, 0x7f, 0xd0, 0x7f, 0xb2, 0x7f, 0xe3, 0x30, 0xc5, 0x6f, 0x56, 0x40, 0x45, 0x41, 0x28, 0x08, 0x03, 0x14,
    0x0e, 0xb4, 0x08, 0xbc, 0x82, 0x40, 0x10, 0x0a, 0x2f, 0x54, 0x26, 0x05, 0x91, 0x7f, 0x44, 0x28, 0xa3, 0x7f, 0x98,
    0x2e, 0xd9, 0xc0, 0x08, 0xb9, 0x33, 0x30, 0x53, 0x09, 0xc1, 0x6f, 0xd3, 0x6f, 0xf4, 0x6f, 0x83, 0x17, 0x47, 0x40,
    0x6c, 0x15, 0xb2, 0x6f, 0xbe, 0x09, 0x75, 0x0b, 0x90, 0x42, 0x45, 0x42, 0x51, 0x0e, 0x32, 0xbc, 0x02, 0x89, 0xa1,
    0x6f, 0x7e, 0x86, 0xf4, 0x7f, 0xd0, 0x7f, 0xb2, 0x7f, 0x04, 0x30, 0x91, 0x6f, 0xd6, 0x2f, 0xeb, 0x6f, 0xa0, 0x5e,
    0xb8, 0x2e, 0x03, 0x2e, 0x97, 0x00, 0x1b, 0xbc, 0x60, 0x50, 0x9f, 0xbc, 0x0c, 0xb8, 0xf0, 0x7f, 0x40, 0xb2, 0xeb,
    0x7f, 0x2b, 0x2f, 0x03, 0x2e, 0x7f, 0x00, 0x41, 0x40, 0x01, 0x2e, 0xc8, 0x00, 0x01, 0x1a, 0x11, 0x2f, 0x37, 0x58,
    0x23, 0x2e, 0xc8, 0x00, 0x10, 0x41, 0xa0, 0x7f, 0x38, 0x81, 0x01, 0x41, 0xd0, 0x7f, 0xb1, 0x7f, 0x98, 0x2e, 0x64,
    0xcf, 0xd0, 0x6f, 0x07, 0x80, 0xa1, 0x6f, 0x11, 0x42, 0x00, 0x2e, 0xb1, 0x6f, 0x01, 0x42, 0x11, 0x30, 0x01, 0x2e,
    0xfc, 0x00, 0x00, 0xa8, 0x03, 0x30, 0xcb, 0x22, 0x4a, 0x25, 0x01, 0x2e, 0x7f, 0x00, 0x3c, 0x89, 0x35, 0x52, 0x05,
    0x54, 0x98, 0x2e, 0xc4, 0xce, 0xc1, 0x6f, 0xf0, 0x6f, 0x98, 0x2e, 0x95, 0xcf, 0x04, 0x2d, 0x01, 0x30, 0xf0, 0x6f,
    0x98, 0x2e, 0x95, 0xcf, 0xeb, 0x6f, 0xa0, 0x5f, 0xb8, 0x2e, 0x03, 0x2e, 0xb3, 0x00, 0x02, 0x32, 0xf0, 0x30, 0x03,
    0x31, 0x30, 0x50, 0x8a, 0x08, 0x08, 0x08, 0xcb, 0x08, 0xe0, 0x7f, 0x80, 0xb2, 0xf3, 0x7f, 0xdb, 0x7f, 0x25, 0x2f,
    0x03, 0x2e, 0xca, 0x00, 0x41, 0x90, 0x04, 0x2f, 0x01, 0x30, 0x23, 0x2e, 0xca, 0x00, 0x98, 0x2e, 0x3f, 0x03, 0xc0,
    0xb2, 0x05, 0x2f, 0x03, 0x2e, 0xda, 0x00, 0x00, 0x30, 0x41, 0x04, 0x23, 0x2e, 0xda, 0x00, 0x98, 0x2e, 0x92, 0xb2,
    0x10, 0x25, 0xf0, 0x6f, 0x00, 0xb2, 0x05, 0x2f, 0x01, 0x2e, 0xda, 0x00, 0x02, 0x30, 0x10, 0x04, 0x21, 0x2e, 0xda,
    0x00, 0x40, 0xb2, 0x01, 0x2f, 0x23, 0x2e, 0xc8, 0x01, 0xdb, 0x6f, 0xe0, 0x6f, 0xd0, 0x5f, 0x80, 0x2e, 0x95, 0xcf,
    0x01, 0x30, 0xe0, 0x6f, 0x98, 0x2e, 0x95, 0xcf, 0x11, 0x30, 0x23, 0x2e, 0xca, 0x00, 0xdb, 0x6f, 0xd0, 0x5f, 0xb8,
    0x2e, 0xd0, 0x50, 0x0a, 0x25, 0x33, 0x84, 0x55, 0x50, 0xd2, 0x7f, 0xe2, 0x7f, 0x03, 0x8c, 0xc0, 0x7f, 0xbb, 0x7f,
    0x00, 0x30, 0x05, 0x5a, 0x39, 0x54, 0x51, 0x41, 0xa5, 0x7f, 0x96, 0x7f, 0x80, 0x7f, 0x98, 0x2e, 0xd9, 0xc0, 0x05,
    0x30, 0xf5, 0x7f, 0x20, 0x25, 0x91, 0x6f, 0x3b, 0x58, 0x3d, 0x5c, 0x3b, 0x56, 0x98, 0x2e, 0x67, 0xcc, 0xc1, 0x6f,
    0xd5, 0x6f, 0x52, 0x40, 0x50, 0x43, 0xc1, 0x7f, 0xd5, 0x7f, 0x10, 0x25, 0x98, 0x2e, 0xfe, 0xc9, 0x10, 0x25, 0x98,
    0x2e, 0x74, 0xc0, 0x86, 0x6f, 0x30, 0x28, 0x92, 0x6f, 0x82, 0x8c, 0xa5, 0x6f, 0x6f, 0x52, 0x69, 0x0e, 0x39, 0x54,
    0xdb, 0x2f, 0x19, 0xa0, 0x15, 0x30, 0x03, 0x2f, 0x00, 0x30, 0x21, 0x2e, 0x81, 0x01, 0x0a, 0x2d, 0x01, 0x2e, 0x81,
    0x01, 0x05, 0x28, 0x42, 0x36, 0x21, 0x2e, 0x81, 0x01, 0x02, 0x0e, 0x01, 0x2f, 0x98, 0x2e, 0xf3, 0x03, 0x57, 0x50,
    0x12, 0x30, 0x01, 0x40, 0x98, 0x2e, 0xfe, 0xc9, 0x51, 0x6f, 0x0b, 0x5c, 0x8e, 0x0e, 0x3b, 0x6f, 0x57, 0x58, 0x02,
    0x30, 0x21, 0x2e, 0x95, 0x01, 0x45, 0x6f, 0x2a, 0x8d, 0xd2, 0x7f, 0xcb, 0x7f, 0x13, 0x2f, 0x02, 0x30, 0x3f, 0x50,
    0xd2, 0x7f, 0xa8, 0x0e, 0x0e, 0x2f, 0xc0, 0x6f, 0x53, 0x54, 0x02, 0x00, 0x51, 0x54, 0x42, 0x0e, 0x10, 0x30, 0x59,
    0x52, 0x02, 0x30, 0x01, 0x2f, 0x00, 0x2e, 0x03, 0x2d, 0x50, 0x42, 0x42, 0x42, 0x12, 0x30, 0xd2, 0x7f, 0x80, 0xb2,
    0x03, 0x2f, 0x00, 0x30, 0x21, 0x2e, 0x80, 0x01, 0x12, 0x2d, 0x01, 0x2e, 0xc9, 0x00, 0x02, 0x80, 0x05, 0x2e, 0x80,
    0x01, 0x11, 0x30, 0x91, 0x28, 0x00, 0x40, 0x25, 0x2e, 0x80, 0x01, 0x10, 0x0e, 0x05, 0x2f, 0x01, 0x2e, 0x7f, 0x01,
    0x01, 0x90, 0x01, 0x2f, 0x98, 0x2e, 0xf3, 0x03, 0x00, 0x2e, 0xa0, 0x41, 0x01, 0x90, 0xa6, 0x7f, 0x90, 0x2e, 0xe3,
    0xb4, 0x01, 0x2e, 0x95, 0x01, 0x00, 0xa8, 0x90, 0x2e, 0xe3, 0xb4, 0x5b, 0x54, 0x95, 0x80, 0x82, 0x40, 0x80, 0xb2,
    0x02, 0x40, 0x2d, 0x8c, 0x3f, 0x52, 0x96, 0x7f, 0x90, 0x2e, 0xc2, 0xb3, 0x29, 0x0e, 0x76, 0x2f, 0x01, 0x2e, 0xc9,
    0x00, 0x00, 0x40, 0x81, 0x28, 0x45, 0x52, 0xb3, 0x30, 0x98, 0x2e, 0x0f, 0xca, 0x5d, 0x54, 0x80, 0x7f, 0x00, 0x2e,
    0xa1, 0x40, 0x72, 0x7f, 0x82, 0x80, 0x82, 0x40, 0x60, 0x7f, 0x98, 0x2e, 0xfe, 0xc9, 0x10, 0x25, 0x98, 0x2e, 0x74,
    0xc0, 0x62, 0x6f, 0x05, 0x30, 0x87, 0x40, 0xc0, 0x91, 0x04, 0x30, 0x05, 0x2f, 0x05, 0x2e, 0x83, 0x01, 0x80, 0xb2,
    0x14, 0x30, 0x00, 0x2f, 0x04, 0x30, 0x05, 0x2e, 0xc9, 0x00, 0x73, 0x6f, 0x81, 0x40, 0xe2, 0x40, 0x69, 0x04, 0x11,
    0x0f, 0xe1, 0x40, 0x16, 0x30, 0xfe, 0x29, 0xcb, 0x40, 0x02, 0x2f, 0x83, 0x6f, 0x83, 0x0f, 0x22, 0x2f, 0x47, 0x56,
    0x13, 0x0f, 0x12, 0x30, 0x77, 0x2f, 0x49, 0x54, 0x42, 0x0e, 0x12, 0x30, 0x73, 0x2f, 0x00, 0x91, 0x0a, 0x2f, 0x01,
    0x2e, 0x8b, 0x01, 0x19, 0xa8, 0x02, 0x30, 0x6c, 0x2f, 0x63, 0x50, 0x00, 0x2e, 0x17, 0x42, 0x05, 0x42, 0x68, 0x2c,
    0x12, 0x30, 0x0b, 0x25, 0x08, 0x0f, 0x50, 0x30, 0x02, 0x2f, 0x21, 0x2e, 0x83, 0x01, 0x03, 0x2d, 0x40, 0x30, 0x21,
    0x2e, 0x83, 0x01, 0x2b, 0x2e, 0x85, 0x01, 0x5a, 0x2c, 0x12, 0x30, 0x00, 0x91, 0x2b, 0x25, 0x04, 0x2f, 0x63, 0x50,
    0x02, 0x30, 0x17, 0x42, 0x17, 0x2c, 0x02, 0x42, 0x98, 0x2e, 0xfe, 0xc9, 0x10, 0x25, 0x98, 0x2e, 0x74, 0xc0, 0x05,
    0x2e, 0xc9, 0x00, 0x81, 0x84, 0x5b, 0x30, 0x82, 0x40, 0x37, 0x2e, 0x83, 0x01, 0x02, 0x0e, 0x07, 0x2f, 0x5f, 0x52,
    0x40, 0x30, 0x62, 0x40, 0x41, 0x40, 0x91, 0x0e, 0x01, 0x2f, 0x21, 0x2e, 0x83, 0x01, 0x05, 0x30, 0x2b, 0x2e, 0x85,
    0x01, 0x12, 0x30, 0x36, 0x2c, 0x16, 0x30, 0x15, 0x25, 0x81, 0x7f, 0x98, 0x2e, 0xfe, 0xc9, 0x10, 0x25, 0x98, 0x2e,
    0x74, 0xc0, 0x19, 0xa2, 0x16, 0x30, 0x15, 0x2f, 0x05, 0x2e, 0x97, 0x01, 0x80, 0x6f, 0x82, 0x0e, 0x05, 0x2f, 0x01,
    0x2e, 0x86, 0x01, 0x06, 0x28, 0x21, 0x2e, 0x86, 0x01, 0x0b, 0x2d, 0x03, 0x2e, 0x87, 0x01, 0x5f, 0x54, 0x4e, 0x28,
    0x91, 0x42, 0x00, 0x2e, 0x82, 0x40, 0x90, 0x0e, 0x01, 0x2f, 0x21, 0x2e, 0x88, 0x01, 0x02, 0x30, 0x13, 0x2c, 0x05,
    0x30, 0xc0, 0x6f, 0x08, 0x1c, 0xa8, 0x0f, 0x16, 0x30, 0x05, 0x30, 0x5b, 0x50, 0x09, 0x2f, 0x02, 0x80, 0x2d, 0x2e,
    0x82, 0x01, 0x05, 0x42, 0x05, 0x80, 0x00, 0x2e, 0x02, 0x42, 0x3e, 0x80, 0x00, 0x2e, 0x06, 0x42, 0x02, 0x30, 0x90,
    0x6f, 0x3e, 0x88, 0x01, 0x40, 0x04, 0x41, 0x4c, 0x28, 0x01, 0x42, 0x07, 0x80, 0x10, 0x25, 0x24, 0x40, 0x00, 0x40,
    0x00, 0xa8, 0xf5, 0x22, 0x23, 0x29, 0x44, 0x42, 0x7a, 0x82, 0x7e, 0x88, 0x43, 0x40, 0x04, 0x41, 0x00, 0xab, 0xf5,
    0x23, 0xdf, 0x28, 0x43, 0x42, 0xd9, 0xa0, 0x14, 0x2f, 0x00, 0x90, 0x02, 0x2f, 0xd2, 0x6f, 0x81, 0xb2, 0x05, 0x2f,
    0x63, 0x54, 0x06, 0x28, 0x90, 0x42, 0x85, 0x42, 0x09, 0x2c, 0x02, 0x30, 0x5b, 0x50, 0x03, 0x80, 0x29, 0x2e, 0x7e,
    0x01, 0x2b, 0x2e, 0x82, 0x01, 0x05, 0x42, 0x12, 0x30, 0x2b, 0x2e, 0x83, 0x01, 0x45, 0x82, 0x00, 0x2e, 0x40, 0x40,
    0x7a, 0x82, 0x02, 0xa0, 0x08, 0x2f, 0x63, 0x50, 0x3b, 0x30, 0x15, 0x42, 0x05, 0x42, 0x37, 0x80, 0x37, 0x2e, 0x7e,
    0x01, 0x05, 0x42, 0x12, 0x30, 0x01, 0x2e, 0xc9, 0x00, 0x02, 0x8c, 0x40, 0x40, 0x84, 0x41, 0x7a, 0x8c, 0x04, 0x0f,
    0x03, 0x2f, 0x01, 0x2e, 0x8b, 0x01, 0x19, 0xa4, 0x04, 0x2f, 0x2b, 0x2e, 0x82, 0x01, 0x98, 0x2e, 0xf3, 0x03, 0x12,
    0x30, 0x81, 0x90, 0x61, 0x52, 0x08, 0x2f, 0x65, 0x42, 0x65, 0x42, 0x43, 0x80, 0x39, 0x84, 0x82, 0x88, 0x05, 0x42,
    0x45, 0x42, 0x85, 0x42, 0x05, 0x43, 0x00, 0x2e, 0x80, 0x41, 0x00, 0x90, 0x90, 0x2e, 0xe1, 0xb4, 0x65, 0x54, 0xc1,
    0x6f, 0x80, 0x40, 0x00, 0xb2, 0x43, 0x58, 0x69, 0x50, 0x44, 0x2f, 0x55, 0x5c, 0xb7, 0x87, 0x8c, 0x0f, 0x0d, 0x2e,
    0x96, 0x01, 0xc4, 0x40, 0x36, 0x2f, 0x41, 0x56, 0x8b, 0x0e, 0x2a, 0x2f, 0x0b, 0x52, 0xa1, 0x0e, 0x0a, 0x2f, 0x05,
    0x2e, 0x8f, 0x01, 0x14, 0x25, 0x98, 0x2e, 0xfe, 0xc9, 0x4b, 0x54, 0x02, 0x0f, 0x69, 0x50, 0x05, 0x30, 0x65, 0x54,
    0x15, 0x2f, 0x03, 0x2e, 0x8e, 0x01, 0x4d, 0x5c, 0x8e, 0x0f, 0x3a, 0x2f, 0x05, 0x2e, 0x8f, 0x01, 0x98, 0x2e, 0xfe,
    0xc9, 0x4f, 0x54, 0x82, 0x0f, 0x05, 0x30, 0x69, 0x50, 0x65, 0x54, 0x30, 0x2f, 0x6d, 0x52, 0x15, 0x30, 0x42, 0x8c,
    0x45, 0x42, 0x04, 0x30, 0x2b, 0x2c, 0x84, 0x43, 0x6b, 0x52, 0x42, 0x8c, 0x00, 0x2e, 0x85, 0x43, 0x15, 0x30, 0x24,
    0x2c, 0x45, 0x42, 0x8e, 0x0f, 0x20, 0x2f, 0x0d, 0x2e, 0x8e, 0x01, 0xb1, 0x0e, 0x1c, 0x2f, 0x23, 0x2e, 0x8e, 0x01,
    0x1a, 0x2d, 0x0e, 0x0e, 0x17, 0x2f, 0xa1, 0x0f, 0x15, 0x2f, 0x23, 0x2e, 0x8d, 0x01, 0x13, 0x2d, 0x98, 0x2e, 0x74,
    0xc0, 0x43, 0x54, 0xc2, 0x0e, 0x0a, 0x2f, 0x65, 0x50, 0x04, 0x80, 0x0b, 0x30, 0x06, 0x82, 0x0b, 0x42, 0x79, 0x80,
    0x41, 0x40, 0x12, 0x30, 0x25, 0x2e, 0x8c, 0x01, 0x01, 0x42, 0x05, 0x30, 0x69, 0x50, 0x65, 0x54, 0x84, 0x82, 0x43,
    0x84, 0xbe, 0x8c, 0x84, 0x40, 0x86, 0x41, 0x26, 0x29, 0x94, 0x42, 0xbe, 0x8e, 0xd5, 0x7f, 0x19, 0xa1, 0x43, 0x40,
    0x0b, 0x2e, 0x8c, 0x01, 0x84, 0x40, 0xc7, 0x41, 0x5d, 0x29, 0x27, 0x29, 0x45, 0x42, 0x84, 0x42, 0xc2, 0x7f, 0x01,
    0x2f, 0xc0, 0xb3, 0x1d, 0x2f, 0x05, 0x2e, 0x94, 0x01, 0x99, 0xa0, 0x01, 0x2f, 0x80, 0xb3, 0x13, 0x2f, 0x80, 0xb3,
    0x18, 0x2f, 0xc0, 0xb3, 0x16, 0x2f, 0x12, 0x40, 0x01, 0x40, 0x92, 0x7f, 0x98, 0x2e, 0x74, 0xc0, 0x92, 0x6f, 0x10,
    0x0f, 0x20, 0x30, 0x03, 0x2f, 0x10, 0x30, 0x21, 0x2e, 0x7e, 0x01, 0x0a, 0x2d, 0x21, 0x2e, 0x7e, 0x01, 0x07, 0x2d,
    0x20, 0x30, 0x21, 0x2e, 0x7e, 0x01, 0x03, 0x2d, 0x10, 0x30, 0x21, 0x2e, 0x7e, 0x01, 0xc2, 0x6f, 0x01, 0x2e, 0xc9,
    0x00, 0xbc, 0x84, 0x02, 0x80, 0x82, 0x40, 0x00, 0x40, 0x90, 0x0e, 0xd5, 0x6f, 0x02, 0x2f, 0x15, 0x30, 0x98, 0x2e,
    0xf3, 0x03, 0x41, 0x91, 0x05, 0x30, 0x07, 0x2f, 0x67, 0x50, 0x3d, 0x80, 0x2b, 0x2e, 0x8f, 0x01, 0x05, 0x42, 0x04,
    0x80, 0x00, 0x2e, 0x05, 0x42, 0x02, 0x2c, 0x00, 0x30, 0x00, 0x30, 0xa2, 0x6f, 0x98, 0x8a, 0x86, 0x40, 0x80, 0xa7,
    0x05, 0x2f, 0x98, 0x2e, 0xf3, 0x03, 0xc0, 0x30, 0x21, 0x2e, 0x95, 0x01, 0x06, 0x25, 0x1a, 0x25, 0xe2, 0x6f, 0x76,
    0x82, 0x96, 0x40, 0x56, 0x43, 0x51, 0x0e, 0xfb, 0x2f, 0xbb, 0x6f, 0x30, 0x5f, 0xb8, 0x2e, 0x01, 0x2e, 0xb8, 0x00,
    0x01, 0x31, 0x41, 0x08, 0x40, 0xb2, 0x20, 0x50, 0xf2, 0x30, 0x02, 0x08, 0xfb, 0x7f, 0x01, 0x30, 0x10, 0x2f, 0x05,
    0x2e, 0xcc, 0x00, 0x81, 0x90, 0xe0, 0x7f, 0x03, 0x2f, 0x23, 0x2e, 0xcc, 0x00, 0x98, 0x2e, 0x55, 0xb6, 0x98, 0x2e,
    0x1d, 0xb5, 0x10, 0x25, 0xfb, 0x6f, 0xe0, 0x6f, 0xe0, 0x5f, 0x80, 0x2e, 0x95, 0xcf, 0x98, 0x2e, 0x95, 0xcf, 0x10,
    0x30, 0x21, 0x2e, 0xcc, 0x00, 0xfb, 0x6f, 0xe0, 0x5f, 0xb8, 0x2e, 0x00, 0x51, 0x05, 0x58, 0xeb, 0x7f, 0x2a, 0x25,
    0x89, 0x52, 0x6f, 0x5a, 0x89, 0x50, 0x13, 0x41, 0x06, 0x40, 0xb3, 0x01, 0x16, 0x42, 0xcb, 0x16, 0x06, 0x40, 0xf3,
    0x02, 0x13, 0x42, 0x65, 0x0e, 0xf5, 0x2f, 0x05, 0x40, 0x14, 0x30, 0x2c, 0x29, 0x04, 0x42, 0x08, 0xa1, 0x00, 0x30,
    0x90, 0x2e, 0x52, 0xb6, 0xb3, 0x88, 0xb0, 0x8a, 0xb6, 0x84, 0xa4, 0x7f, 0xc4, 0x7f, 0xb5, 0x7f, 0xd5, 0x7f, 0x92,
    0x7f, 0x73, 0x30, 0x04, 0x30, 0x55, 0x40, 0x42, 0x40, 0x8a, 0x17, 0xf3, 0x08, 0x6b, 0x01, 0x90, 0x02, 0x53, 0xb8,
    0x4b, 0x82, 0xad, 0xbe, 0x71, 0x7f, 0x45, 0x0a, 0x09, 0x54, 0x84, 0x7f, 0x98, 0x2e, 0xd9, 0xc0, 0xa3, 0x6f, 0x7b,
    0x54, 0xd0, 0x42, 0xa3, 0x7f, 0xf2, 0x7f, 0x60, 0x7f, 0x20, 0x25, 0x71, 0x6f, 0x75, 0x5a, 0x77, 0x58, 0x79, 0x5c,
    0x75, 0x56, 0x98, 0x2e, 0x67, 0xcc, 0xb1, 0x6f, 0x62, 0x6f, 0x50, 0x42, 0xb1, 0x7f, 0xb3, 0x30, 0x10, 0x25, 0x98,
    0x2e, 0x0f, 0xca, 0x84, 0x6f, 0x20, 0x29, 0x71, 0x6f, 0x92, 0x6f, 0xa5, 0x6f, 0x76, 0x82, 0x6a, 0x0e, 0x73, 0x30,
    0x00, 0x30, 0xd0, 0x2f, 0xd2, 0x6f, 0xd1, 0x7f, 0xb4, 0x7f, 0x98, 0x2e, 0x2b, 0xb7, 0x15, 0xbd, 0x0b, 0xb8, 0x02,
    0x0a, 0xc2, 0x6f, 0xc0, 0x7f, 0x98, 0x2e, 0x2b, 0xb7, 0x15, 0xbd, 0x0b, 0xb8, 0x42, 0x0a, 0xc0, 0x6f, 0x08, 0x17,
    0x41, 0x18, 0x89, 0x16, 0xe1, 0x18, 0xd0, 0x18, 0xa1, 0x7f, 0x27, 0x25, 0x16, 0x25, 0x98, 0x2e, 0x79, 0xc0, 0x8b,
    0x54, 0x90, 0x7f, 0xb3, 0x30, 0x82, 0x40, 0x80, 0x90, 0x0d, 0x2f, 0x7d, 0x52, 0x92, 0x6f, 0x98, 0x2e, 0x0f, 0xca,
    0xb2, 0x6f, 0x90, 0x0e, 0x06, 0x2f, 0x8b, 0x50, 0x14, 0x30, 0x42, 0x6f, 0x51, 0x6f, 0x14, 0x42, 0x12, 0x42, 0x01,
    0x42, 0x00, 0x2e, 0x31, 0x6f, 0x98, 0x2e, 0x74, 0xc0, 0x41, 0x6f, 0x80, 0x7f, 0x98, 0x2e, 0x74, 0xc0, 0x82, 0x6f,
    0x10, 0x04, 0x43, 0x52, 0x01, 0x0f, 0x05, 0x2e, 0xcb, 0x00, 0x00, 0x30, 0x04, 0x30, 0x21, 0x2f, 0x51, 0x6f, 0x43,
    0x58, 0x8c, 0x0e, 0x04, 0x30, 0x1c, 0x2f, 0x85, 0x88, 0x41, 0x6f, 0x04, 0x41, 0x8c, 0x0f, 0x04, 0x30, 0x16, 0x2f,
    0x84, 0x88, 0x00, 0x2e, 0x04, 0x41, 0x04, 0x05, 0x8c, 0x0e, 0x04, 0x30, 0x0f, 0x2f, 0x82, 0x88, 0x31, 0x6f, 0x04,
    0x41, 0x04, 0x05, 0x8c, 0x0e, 0x04, 0x30, 0x08, 0x2f, 0x83, 0x88, 0x00, 0x2e, 0x04, 0x41, 0x8c, 0x0f, 0x04, 0x30,
    0x02, 0x2f, 0x21, 0x2e, 0xad, 0x01, 0x14, 0x30, 0x00, 0x91, 0x14, 0x2f, 0x03, 0x2e, 0xa1, 0x01, 0x41, 0x90, 0x0e,
    0x2f, 0x03, 0x2e, 0xad, 0x01, 0x14, 0x30, 0x4c, 0x28, 0x23, 0x2e, 0xad, 0x01, 0x46, 0xa0, 0x06, 0x2f, 0x81, 0x84,
    0x8d, 0x52, 0x48, 0x82, 0x82, 0x40, 0x21, 0x2e, 0xa1, 0x01, 0x42, 0x42, 0x5c, 0x2c, 0x02, 0x30, 0x05, 0x2e, 0xaa,
    0x01, 0x80, 0xb2, 0x02, 0x30, 0x55, 0x2f, 0x03, 0x2e, 0xa9, 0x01, 0x92, 0x6f, 0xb3, 0x30, 0x98, 0x2e, 0x0f, 0xca,
    0xb2, 0x6f, 0x90, 0x0f, 0x00, 0x30, 0x02, 0x30, 0x4a, 0x2f, 0xa2, 0x6f, 0x87, 0x52, 0x91, 0x00, 0x85, 0x52, 0x51,
    0x0e, 0x02, 0x2f, 0x00, 0x2e, 0x43, 0x2c, 0x02, 0x30, 0xc2, 0x6f, 0x7f, 0x52, 0x91, 0x0e, 0x02, 0x30, 0x3c, 0x2f,
    0x51, 0x6f, 0x81, 0x54, 0x98, 0x2e, 0xfe, 0xc9, 0x10, 0x25, 0xb3, 0x30, 0x21, 0x25, 0x98, 0x2e, 0x0f, 0xca, 0x32,
    0x6f, 0xc0, 0x7f, 0xb3, 0x30, 0x12, 0x25, 0x98, 0x2e, 0x0f, 0xca, 0x42, 0x6f, 0xb0, 0x7f, 0xb3, 0x30, 0x12, 0x25,
    0x98, 0x2e, 0x0f, 0xca, 0xb2, 0x6f, 0x90, 0x28, 0x83, 0x52, 0x98, 0x2e, 0xfe, 0xc9, 0xc2, 0x6f, 0x90, 0x0f, 0x00,
    0x30, 0x02, 0x30, 0x1d, 0x2f, 0x05, 0x2e, 0xa1, 0x01, 0x80, 0xb2, 0x12, 0x30, 0x0f, 0x2f, 0x42, 0x6f, 0x03, 0x2e,
    0xab, 0x01, 0x91, 0x0e, 0x02, 0x30, 0x12, 0x2f, 0x52, 0x6f, 0x03, 0x2e, 0xac, 0x01, 0x91, 0x0f, 0x02, 0x30, 0x0c,
    0x2f, 0x21, 0x2e, 0xaa, 0x01, 0x0a, 0x2c, 0x12, 0x30, 0x03, 0x2e, 0xcb, 0x00, 0x8d, 0x58, 0x08, 0x89, 0x41, 0x40,
    0x11, 0x43, 0x00, 0x43, 0x25, 0x2e, 0xa1, 0x01, 0xd4, 0x6f, 0x8f, 0x52, 0x00, 0x43, 0x3a, 0x89, 0x00, 0x2e, 0x10,
    0x43, 0x10, 0x43, 0x61, 0x0e, 0xfb, 0x2f, 0x03, 0x2e, 0xa0, 0x01, 0x11, 0x1a, 0x02, 0x2f, 0x02, 0x25, 0x21, 0x2e,
    0xa0, 0x01, 0xeb, 0x6f, 0x00, 0x5f, 0xb8, 0x2e, 0x91, 0x52, 0x10, 0x30, 0x02, 0x30, 0x95, 0x56, 0x52, 0x42, 0x4b,
    0x0e, 0xfc, 0x2f, 0x8d, 0x54, 0x88, 0x82, 0x93, 0x56, 0x80, 0x42, 0x53, 0x42, 0x40, 0x42, 0x42, 0x86, 0x83, 0x54,
    0xc0, 0x2e, 0xc2, 0x42, 0x00, 0x2e, 0xa3, 0x52, 0x00, 0x51, 0x52, 0x40, 0x47, 0x40, 0x1a, 0x25, 0x01, 0x2e, 0x97,
    0x00, 0x8f, 0xbe, 0x72, 0x86, 0xfb, 0x7f, 0x0b, 0x30, 0x7c, 0xbf, 0xa5, 0x50, 0x10, 0x08, 0xdf, 0xba, 0x70, 0x88,
    0xf8, 0xbf, 0xcb, 0x42, 0xd3, 0x7f, 0x6c, 0xbb, 0xfc, 0xbb, 0xc5, 0x0a, 0x90, 0x7f, 0x1b, 0x7f, 0x0b, 0x43, 0xc0,
    0xb2, 0xe5, 0x7f, 0xb7, 0x7f, 0xa6, 0x7f, 0xc4, 0x7f, 0x90, 0x2e, 0x1c, 0xb7, 0x07, 0x2e, 0xd2, 0x00, 0xc0, 0xb2,
    0x0b, 0x2f, 0x97, 0x52, 0x01, 0x2e, 0xcd, 0x00, 0x82, 0x7f, 0x98, 0x2e, 0xbb, 0xcc, 0x0b, 0x30, 0x37, 0x2e, 0xd2,
    0x00, 0x82, 0x6f, 0x90, 0x6f, 0x1a, 0x25, 0x00, 0xb2, 0x8b, 0x7f, 0x14, 0x2f, 0xa6, 0xbd, 0x25, 0xbd, 0xb6, 0xb9,
    0x2f, 0xb9, 0x80, 0xb2, 0xd4, 0xb0, 0x0c, 0x2f, 0x99, 0x54, 0x9b, 0x56, 0x0b, 0x30, 0x0b, 0x2e, 0xb1, 0x00, 0xa1,
    0x58, 0x9b, 0x42, 0xdb, 0x42, 0x6c, 0x09, 0x2b, 0x2e, 0xb1, 0x00, 0x8b, 0x42, 0xcb, 0x42, 0x86, 0x7f, 0x73, 0x84,
    0xa7, 0x56, 0xc3, 0x08, 0x39, 0x52, 0x05, 0x50, 0x72, 0x7f, 0x63, 0x7f, 0x98, 0x2e, 0xc2, 0xc0, 0xe1, 0x6f, 0x62,
    0x6f, 0xd1, 0x0a, 0x01, 0x2e, 0xcd, 0x00, 0xd5, 0x6f, 0xc4, 0x6f, 0x72, 0x6f, 0x97, 0x52, 0x9d, 0x5c, 0x98, 0x2e,
    0x06, 0xcd, 0x23, 0x6f, 0x90, 0x6f, 0x99, 0x52, 0xc0, 0xb2, 0x04, 0xbd, 0x54, 0x40, 0xaf, 0xb9, 0x45, 0x40, 0xe1,
    0x7f, 0x02, 0x30, 0x06, 0x2f, 0xc0, 0xb2, 0x02, 0x30, 0x03, 0x2f, 0x9b, 0x5c, 0x12, 0x30, 0x94, 0x43, 0x85, 0x43,
    0x03, 0xbf, 0x6f, 0xbb, 0x80, 0xb3, 0x20, 0x2f, 0x06, 0x6f, 0x26, 0x01, 0x16, 0x6f, 0x6e, 0x03, 0x45, 0x42, 0xc0,
    0x90, 0x29, 0x2e, 0xce, 0x00, 0x9b, 0x52, 0x14, 0x2f, 0x9b, 0x5c, 0x00, 0x2e, 0x93, 0x41, 0x86, 0x41, 0xe3, 0x04,
    0xae, 0x07, 0x80, 0xab, 0x04, 0x2f, 0x80, 0x91, 0x0a, 0x2f, 0x86, 0x6f, 0x73, 0x0f, 0x07, 0x2f, 0x83, 0x6f, 0xc0,
    0xb2, 0x04, 0x2f, 0x54, 0x42, 0x45, 0x42, 0x12, 0x30, 0x04, 0x2c, 0x11, 0x30, 0x02, 0x2c, 0x11, 0x30, 0x11, 0x30,
    0x02, 0xbc, 0x0f, 0xb8, 0xd2, 0x7f, 0x00, 0xb2, 0x0a, 0x2f, 0x01, 0x2e, 0xfc, 0x00, 0x05, 0x2e, 0xc7, 0x01, 0x10,
    0x1a, 0x02, 0x2f, 0x21, 0x2e, 0xc7, 0x01, 0x03, 0x2d, 0x02, 0x2c, 0x01, 0x30, 0x01, 0x30, 0xb0, 0x6f, 0x98, 0x2e,
    0x95, 0xcf, 0xd1, 0x6f, 0xa0, 0x6f, 0x98, 0x2e, 0x95, 0xcf, 0xe2, 0x6f, 0x9f, 0x52, 0x01, 0x2e, 0xce, 0x00, 0x82,
    0x40, 0x50, 0x42, 0x0c, 0x2c, 0x42, 0x42, 0x11, 0x30, 0x23, 0x2e, 0xd2, 0x00, 0x01, 0x30, 0xb0, 0x6f, 0x98, 0x2e,
    0x95, 0xcf, 0xa0, 0x6f, 0x01, 0x30, 0x98, 0x2e, 0x95, 0xcf, 0x00, 0x2e, 0xfb, 0x6f, 0x00, 0x5f, 0xb8, 0x2e, 0x83,
    0x86, 0x01, 0x30, 0x00, 0x30, 0x94, 0x40, 0x24, 0x18, 0x06, 0x00, 0x53, 0x0e, 0x4f, 0x02, 0xf9, 0x2f, 0xb8, 0x2e,
    0xa9, 0x52, 0x00, 0x2e, 0x60, 0x40, 0x41, 0x40, 0x0d, 0xbc, 0x98, 0xbc, 0xc0, 0x2e, 0x01, 0x0a, 0x0f, 0xb8, 0xab,
    0x52, 0x53, 0x3c, 0x52, 0x40, 0x40, 0x40, 0x4b, 0x00, 0x82, 0x16, 0x26, 0xb9, 0x01, 0xb8, 0x41, 0x40, 0x10, 0x08,
    0x97, 0xb8, 0x01, 0x08, 0xc0, 0x2e, 0x11, 0x30, 0x01, 0x08, 0x43, 0x86, 0x25, 0x40, 0x04, 0x40, 0xd8, 0xbe, 0x2c,
    0x0b, 0x22, 0x11, 0x54, 0x42, 0x03, 0x80, 0x4b, 0x0e, 0xf6, 0x2f, 0xb8, 0x2e, 0x9f, 0x50, 0x10, 0x50, 0xad, 0x52,
    0x05, 0x2e, 0xd3, 0x00, 0xfb, 0x7f, 0x00, 0x2e, 0x13, 0x40, 0x93, 0x42, 0x41, 0x0e, 0xfb, 0x2f, 0x98, 0x2e, 0xa5,
    0xb7, 0x98, 0x2e, 0x87, 0xcf, 0x01, 0x2e, 0xd9, 0x00, 0x00, 0xb2, 0xfb, 0x6f, 0x0b, 0x2f, 0x01, 0x2e, 0x69, 0xf7,
    0xb1, 0x3f, 0x01, 0x08, 0x01, 0x30, 0xf0, 0x5f, 0x23, 0x2e, 0xd9, 0x00, 0x21, 0x2e, 0x69, 0xf7, 0x80, 0x2e, 0x7a,
    0xb7, 0xf0, 0x5f, 0xb8, 0x2e, 0x01, 0x2e, 0xc0, 0xf8, 0x03, 0x2e, 0xfc, 0xf5, 0x15, 0x54, 0xaf, 0x56, 0x82, 0x08,
    0x0b, 0x2e, 0x69, 0xf7, 0xcb, 0x0a, 0xb1, 0x58, 0x80, 0x90, 0xdd, 0xbe, 0x4c, 0x08, 0x5f, 0xb9, 0x59, 0x22, 0x80,
    0x90, 0x07, 0x2f, 0x03, 0x34, 0xc3, 0x08, 0xf2, 0x3a, 0x0a, 0x08, 0x02, 0x35, 0xc0, 0x90, 0x4a, 0x0a, 0x48, 0x22,
    0xc0, 0x2e, 0x23, 0x2e, 0xfc, 0xf5, 0x10, 0x50, 0xfb, 0x7f, 0x98, 0x2e, 0x56, 0xc7, 0x98, 0x2e, 0x49, 0xc3, 0x10,
    0x30, 0xfb, 0x6f, 0xf0, 0x5f, 0x21, 0x2e, 0xcc, 0x00, 0x21, 0x2e, 0xca, 0x00, 0xb8, 0x2e, 0x03, 0x2e, 0xd3, 0x00,
    0x16, 0xb8, 0x02, 0x34, 0x4a, 0x0c, 0x21, 0x2e, 0x2d, 0xf5, 0xc0, 0x2e, 0x23, 0x2e, 0xd3, 0x00, 0x03, 0xbc, 0x21,
    0x2e, 0xd5, 0x00, 0x03, 0x2e, 0xd5, 0x00, 0x40, 0xb2, 0x10, 0x30, 0x21, 0x2e, 0x77, 0x00, 0x01, 0x30, 0x05, 0x2f,
    0x05, 0x2e, 0xd8, 0x00, 0x80, 0x90, 0x01, 0x2f, 0x23, 0x2e, 0x6f, 0xf5, 0xc0, 0x2e, 0x21, 0x2e, 0xd9, 0x00, 0x11,
    0x30, 0x81, 0x08, 0x01, 0x2e, 0x6a, 0xf7, 0x71, 0x3f, 0x23, 0xbd, 0x01, 0x08, 0x02, 0x0a, 0xc0, 0x2e, 0x21, 0x2e,
    0x6a, 0xf7, 0x30, 0x25, 0x00, 0x30, 0x21, 0x2e, 0x5a, 0xf5, 0x10, 0x50, 0x21, 0x2e, 0x7b, 0x00, 0x21, 0x2e, 0x7c,
    0x00, 0xfb, 0x7f, 0x98, 0x2e, 0xc3, 0xb7, 0x40, 0x30, 0x21, 0x2e, 0xd4, 0x00, 0xfb, 0x6f, 0xf0, 0x5f, 0x03, 0x25,
    0x80, 0x2e, 0xaf, 0xb7, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00,
    0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e,
    0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80,
    0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x01, 0x2e, 0x5d, 0xf7, 0x08, 0xbc, 0x80, 0xac, 0x0e, 0xbb, 0x02, 0x2f,
    0x00, 0x30, 0x41, 0x04, 0x82, 0x06, 0xc0, 0xa4, 0x00, 0x30, 0x11, 0x2f, 0x40, 0xa9, 0x03, 0x2f, 0x40, 0x91, 0x0d,
    0x2f, 0x00, 0xa7, 0x0b, 0x2f, 0x80, 0xb3, 0xb3, 0x58, 0x02, 0x2f, 0x90, 0xa1, 0x26, 0x13, 0x20, 0x23, 0x80, 0x90,
    0x10, 0x30, 0x01, 0x2f, 0xcc, 0x0e, 0x00, 0x2f, 0x00, 0x30, 0xb8, 0x2e, 0xb5, 0x50, 0x18, 0x08, 0x08, 0xbc, 0x88,
    0xb6, 0x0d, 0x17, 0xc6, 0xbd, 0x56, 0xbc, 0xb7, 0x58, 0xda, 0xba, 0x04, 0x01, 0x1d, 0x0a, 0x10, 0x50, 0x05, 0x30,
    0x32, 0x25, 0x45, 0x03, 0xfb, 0x7f, 0xf6, 0x30, 0x21, 0x25, 0x98, 0x2e, 0x37, 0xca, 0x16, 0xb5, 0x9a, 0xbc, 0x06,
    0xb8, 0x80, 0xa8, 0x41, 0x0a, 0x0e, 0x2f, 0x80, 0x90, 0x02, 0x2f, 0x2d, 0x50, 0x48, 0x0f, 0x09, 0x2f, 0xbf, 0xa0,
    0x04, 0x2f, 0xbf, 0x90, 0x06, 0x2f, 0xb7, 0x54, 0xca, 0x0f, 0x03, 0x2f, 0x00, 0x2e, 0x02, 0x2c, 0xb7, 0x52, 0x2d,
    0x52, 0xf2, 0x33, 0x98, 0x2e, 0xd9, 0xc0, 0xfb, 0x6f, 0xf1, 0x37, 0xc0, 0x2e, 0x01, 0x08, 0xf0, 0x5f, 0xbf, 0x56,
    0xb9, 0x54, 0xd0, 0x40, 0xc4, 0x40, 0x0b, 0x2e, 0xfd, 0xf3, 0xbf, 0x52, 0x90, 0x42, 0x94, 0x42, 0x95, 0x42, 0x05,
    0x30, 0xc1, 0x50, 0x0f, 0x88, 0x06, 0x40, 0x04, 0x41, 0x96, 0x42, 0xc5, 0x42, 0x48, 0xbe, 0x73, 0x30, 0x0d, 0x2e,
    0xd8, 0x00, 0x4f, 0xba, 0x84, 0x42, 0x03, 0x42, 0x81, 0xb3, 0x02, 0x2f, 0x2b, 0x2e, 0x6f, 0xf5, 0x06, 0x2d, 0x05,
    0x2e, 0x77, 0xf7, 0xbd, 0x56, 0x93, 0x08, 0x25, 0x2e, 0x77, 0xf7, 0xbb, 0x54, 0x25, 0x2e, 0xc2, 0xf5, 0x07, 0x2e,
    0xfd, 0xf3, 0x42, 0x30, 0xb4, 0x33, 0xda, 0x0a, 0x4c, 0x00, 0x27, 0x2e, 0xfd, 0xf3, 0x43, 0x40, 0xd4, 0x3f, 0xdc,
    0x08, 0x43, 0x42, 0x00, 0x2e, 0x00, 0x2e, 0x43, 0x40, 0x24, 0x30, 0xdc, 0x0a, 0x43, 0x42, 0x04, 0x80, 0x03, 0x2e,
    0xfd, 0xf3, 0x4a, 0x0a, 0x23, 0x2e, 0xfd, 0xf3, 0x61, 0x34, 0xc0, 0x2e, 0x01, 0x42, 0x00, 0x2e, 0x60, 0x50, 0x1a,
    0x25, 0x7a, 0x86, 0xe0, 0x7f, 0xf3, 0x7f, 0x03, 0x25, 0xc3, 0x52, 0x41, 0x84, 0xdb, 0x7f, 0x33, 0x30, 0x98, 0x2e,
    0x16, 0xc2, 0x1a, 0x25, 0x7d, 0x82, 0xf0, 0x6f, 0xe2, 0x6f, 0x32, 0x25, 0x16, 0x40, 0x94, 0x40, 0x26, 0x01, 0x85,
    0x40, 0x8e, 0x17, 0xc4, 0x42, 0x6e, 0x03, 0x95, 0x42, 0x41, 0x0e, 0xf4, 0x2f, 0xdb, 0x6f, 0xa0, 0x5f, 0xb8, 0x2e,
    0xb0, 0x51, 0xfb, 0x7f, 0x98, 0x2e, 0xe8, 0x0d, 0x5a, 0x25, 0x98, 0x2e, 0x0f, 0x0e, 0xcb, 0x58, 0x32, 0x87, 0xc4,
    0x7f, 0x65, 0x89, 0x6b, 0x8d, 0xc5, 0x5a, 0x65, 0x7f, 0xe1, 0x7f, 0x83, 0x7f, 0xa6, 0x7f, 0x74, 0x7f, 0xd0, 0x7f,
    0xb6, 0x7f, 0x94, 0x7f, 0x17, 0x30, 0xc7, 0x52, 0xc9, 0x54, 0x51, 0x7f, 0x00, 0x2e, 0x85, 0x6f, 0x42, 0x7f, 0x00,
    0x2e, 0x51, 0x41, 0x45, 0x81, 0x42, 0x41, 0x13, 0x40, 0x3b, 0x8a, 0x00, 0x40, 0x4b, 0x04, 0xd0, 0x06, 0xc0, 0xac,
    0x85, 0x7f, 0x02, 0x2f, 0x02, 0x30, 0x51, 0x04, 0xd3, 0x06, 0x41, 0x84, 0x05, 0x30, 0x5d, 0x02, 0xc9, 0x16, 0xdf,
    0x08, 0xd3, 0x00, 0x8d, 0x02, 0xaf, 0xbc, 0xb1, 0xb9, 0x59, 0x0a, 0x65, 0x6f, 0x11, 0x43, 0xa1, 0xb4, 0x52, 0x41,
    0x53, 0x41, 0x01, 0x43, 0x34, 0x7f, 0x65, 0x7f, 0x26, 0x31, 0xe5, 0x6f, 0xd4, 0x6f, 0x98, 0x2e, 0x37, 0xca, 0x32,
    0x6f, 0x75, 0x6f, 0x83, 0x40, 0x42, 0x41, 0x23, 0x7f, 0x12, 0x7f, 0xf6, 0x30, 0x40, 0x25, 0x51, 0x25, 0x98, 0x2e,
    0x37, 0xca, 0x14, 0x6f, 0x20, 0x05, 0x70, 0x6f, 0x25, 0x6f, 0x69, 0x07, 0xa2, 0x6f, 0x31, 0x6f, 0x0b, 0x30, 0x04,
    0x42, 0x9b, 0x42, 0x8b, 0x42, 0x55, 0x42, 0x32, 0x7f, 0x40, 0xa9, 0xc3, 0x6f, 0x71, 0x7f, 0x02, 0x30, 0xd0, 0x40,
    0xc3, 0x7f, 0x03, 0x2f, 0x40, 0x91, 0x15, 0x2f, 0x00, 0xa7, 0x13, 0x2f, 0x00, 0xa4, 0x11, 0x2f, 0x84, 0xbd, 0x98,
    0x2e, 0x79, 0xca, 0x55, 0x6f, 0xb7, 0x54, 0x54, 0x41, 0x82, 0x00, 0xf3, 0x3f, 0x45, 0x41, 0xcb, 0x02, 0xf6, 0x30,
    0x98, 0x2e, 0x37, 0xca, 0x35, 0x6f, 0xa4, 0x6f, 0x41, 0x43, 0x03, 0x2c, 0x00, 0x43, 0xa4, 0x6f, 0x35, 0x6f, 0x17,
    0x30, 0x42, 0x6f, 0x51, 0x6f, 0x93, 0x40, 0x42, 0x82, 0x00, 0x41, 0xc3, 0x00, 0x03, 0x43, 0x51, 0x7f, 0x00, 0x2e,
    0x94, 0x40, 0x41, 0x41, 0x4c, 0x02, 0xc4, 0x6f, 0xd1, 0x56, 0x63, 0x0e, 0x74, 0x6f, 0x51, 0x43, 0xa5, 0x7f, 0x8a,
    0x2f, 0x09, 0x2e, 0xd8, 0x00, 0x01, 0xb3, 0x21, 0x2f, 0xcb, 0x58, 0x90, 0x6f, 0x13, 0x41, 0xb6, 0x6f, 0xe4, 0x7f,
    0x00, 0x2e, 0x91, 0x41, 0x14, 0x40, 0x92, 0x41, 0x15, 0x40, 0x17, 0x2e, 0x6f, 0xf5, 0xb6, 0x7f, 0xd0, 0x7f, 0xcb,
    0x7f, 0x98, 0x2e, 0x00, 0x0c, 0x07, 0x15, 0xc2, 0x6f, 0x14, 0x0b, 0x29, 0x2e, 0x6f, 0xf5, 0xc3, 0xa3, 0xc1, 0x8f,
    0xe4, 0x6f, 0xd0, 0x6f, 0xe6, 0x2f, 0x14, 0x30, 0x05, 0x2e, 0x6f, 0xf5, 0x14, 0x0b, 0x29, 0x2e, 0x6f, 0xf5, 0x18,
    0x2d, 0xcd, 0x56, 0x04, 0x32, 0xb5, 0x6f, 0x1c, 0x01, 0x51, 0x41, 0x52, 0x41, 0xc3, 0x40, 0xb5, 0x7f, 0xe4, 0x7f,
    0x98, 0x2e, 0x1f, 0x0c, 0xe4, 0x6f, 0x21, 0x87, 0x00, 0x43, 0x04, 0x32, 0xcf, 0x54, 0x5a, 0x0e, 0xef, 0x2f, 0x15,
    0x54, 0x09, 0x2e, 0x77, 0xf7, 0x22, 0x0b, 0x29, 0x2e, 0x77, 0xf7, 0xfb, 0x6f, 0x50, 0x5e, 0xb8, 0x2e, 0x10, 0x50,
    0x01, 0x2e, 0xd4, 0x00, 0x00, 0xb2, 0xfb, 0x7f, 0x51, 0x2f, 0x01, 0xb2, 0x48, 0x2f, 0x02, 0xb2, 0x42, 0x2f, 0x03,
    0x90, 0x56, 0x2f, 0xd7, 0x52, 0x79, 0x80, 0x42, 0x40, 0x81, 0x84, 0x00, 0x40, 0x42, 0x42, 0x98, 0x2e, 0x93, 0x0c,
    0xd9, 0x54, 0xd7, 0x50, 0xa1, 0x40, 0x98, 0xbd, 0x82, 0x40, 0x3e, 0x82, 0xda, 0x0a, 0x44, 0x40, 0x8b, 0x16, 0xe3,
    0x00, 0x53, 0x42, 0x00, 0x2e, 0x43, 0x40, 0x9a, 0x02, 0x52, 0x42, 0x00, 0x2e, 0x41, 0x40, 0x15, 0x54, 0x4a, 0x0e,
    0x3a, 0x2f, 0x3a, 0x82, 0x00, 0x30, 0x41, 0x40, 0x21, 0x2e, 0x85, 0x0f, 0x40, 0xb2, 0x0a, 0x2f, 0x98, 0x2e, 0xb1,
    0x0c, 0x98, 0x2e, 0x45, 0x0e, 0x98, 0x2e, 0x5b, 0x0e, 0xfb, 0x6f, 0xf0, 0x5f, 0x00, 0x30, 0x80, 0x2e, 0xce, 0xb7,
    0xdd, 0x52, 0xd3, 0x54, 0x42, 0x42, 0x4f, 0x84, 0x73, 0x30, 0xdb, 0x52, 0x83, 0x42, 0x1b, 0x30, 0x6b, 0x42, 0x23,
    0x30, 0x27, 0x2e, 0xd7, 0x00, 0x37, 0x2e, 0xd4, 0x00, 0x21, 0x2e, 0xd6, 0x00, 0x7a, 0x84, 0x17, 0x2c, 0x42, 0x42,
    0x30, 0x30, 0x21, 0x2e, 0xd4, 0x00, 0x12, 0x2d, 0x21, 0x30, 0x00, 0x30, 0x23, 0x2e, 0xd4, 0x00, 0x21, 0x2e, 0x7b,
    0xf7, 0x0b, 0x2d, 0x17, 0x30, 0x98, 0x2e, 0x51, 0x0c, 0xd5, 0x50, 0x0c, 0x82, 0x72, 0x30, 0x2f, 0x2e, 0xd4, 0x00,
    0x25, 0x2e, 0x7b, 0xf7, 0x40, 0x42, 0x00, 0x2e, 0xfb, 0x6f, 0xf0, 0x5f, 0xb8, 0x2e, 0x70, 0x50, 0x0a, 0x25, 0x39,
    0x86, 0xfb, 0x7f, 0xe1, 0x32, 0x62, 0x30, 0x98, 0x2e, 0xc2, 0xc4, 0xb5, 0x56, 0xa5, 0x6f, 0xab, 0x08, 0x91, 0x6f,
    0x4b, 0x08, 0xdf, 0x56, 0xc4, 0x6f, 0x23, 0x09, 0x4d, 0xba, 0x93, 0xbc, 0x8c, 0x0b, 0xd1, 0x6f, 0x0b, 0x09, 0xcb,
    0x52, 0xe1, 0x5e, 0x56, 0x42, 0xaf, 0x09, 0x4d, 0xba, 0x23, 0xbd, 0x94, 0x0a, 0xe5, 0x6f, 0x68, 0xbb, 0xeb, 0x08,
    0xbd, 0xb9, 0x63, 0xbe, 0xfb, 0x6f, 0x52, 0x42, 0xe3, 0x0a, 0xc0, 0x2e, 0x43, 0x42, 0x90, 0x5f, 0xd1, 0x50, 0x03,
    0x2e, 0x25, 0xf3, 0x13, 0x40, 0x00, 0x40, 0x9b, 0xbc, 0x9b, 0xb4, 0x08, 0xbd, 0xb8, 0xb9, 0x98, 0xbc, 0xda, 0x0a,
    0x08, 0xb6, 0x89, 0x16, 0xc0, 0x2e, 0x19, 0x00, 0x62, 0x02, 0x10, 0x50, 0xfb, 0x7f, 0x98, 0x2e, 0x81, 0x0d, 0x01,
    0x2e, 0xd4, 0x00, 0x31, 0x30, 0x08, 0x04, 0xfb, 0x6f, 0x01, 0x30, 0xf0, 0x5f, 0x23, 0x2e, 0xd6, 0x00, 0x21, 0x2e,
    0xd7, 0x00, 0xb8, 0x2e, 0x01, 0x2e, 0xd7, 0x00, 0x03, 0x2e, 0xd6, 0x00, 0x48, 0x0e, 0x01, 0x2f, 0x80, 0x2e, 0x1f,
    0x0e, 0xb8, 0x2e, 0xe3, 0x50, 0x21, 0x34, 0x01, 0x42, 0x82, 0x30, 0xc1, 0x32, 0x25, 0x2e, 0x62, 0xf5, 0x01, 0x00,
    0x22, 0x30, 0x01, 0x40, 0x4a, 0x0a, 0x01, 0x42, 0xb8, 0x2e, 0xe3, 0x54, 0xf0, 0x3b, 0x83, 0x40, 0xd8, 0x08, 0xe5,
    0x52, 0x83, 0x42, 0x00, 0x30, 0x83, 0x30, 0x50, 0x42, 0xc4, 0x32, 0x27, 0x2e, 0x64, 0xf5, 0x94, 0x00, 0x50, 0x42,
    0x40, 0x42, 0xd3, 0x3f, 0x84, 0x40, 0x7d, 0x82, 0xe3, 0x08, 0x40, 0x42, 0x83, 0x42, 0xb8, 0x2e, 0xdd, 0x52, 0x00,
    0x30, 0x40, 0x42, 0x7c, 0x86, 0xb9, 0x52, 0x09, 0x2e, 0x70, 0x0f, 0xbf, 0x54, 0xc4, 0x42, 0xd3, 0x86, 0x54, 0x40,
    0x55, 0x40, 0x94, 0x42, 0x85, 0x42, 0x21, 0x2e, 0xd7, 0x00, 0x42, 0x40, 0x25, 0x2e, 0xfd, 0xf3, 0xc0, 0x42, 0x7e,
    0x82, 0x05, 0x2e, 0x7d, 0x00, 0x80, 0xb2, 0x14, 0x2f, 0x05, 0x2e, 0x89, 0x00, 0x27, 0xbd, 0x2f, 0xb9, 0x80, 0x90,
    0x02, 0x2f, 0x21, 0x2e, 0x6f, 0xf5, 0x0c, 0x2d, 0x07, 0x2e, 0x71, 0x0f, 0x14, 0x30, 0x1c, 0x09, 0x05, 0x2e, 0x77,
    0xf7, 0xbd, 0x56, 0x47, 0xbe, 0x93, 0x08, 0x94, 0x0a, 0x25, 0x2e, 0x77, 0xf7, 0xe7, 0x54, 0x50, 0x42, 0x4a, 0x0e,
    0xfc, 0x2f, 0xb8, 0x2e, 0x50, 0x50, 0x02, 0x30, 0x43, 0x86, 0xe5, 0x50, 0xfb, 0x7f, 0xe3, 0x7f, 0xd2, 0x7f, 0xc0,
    0x7f, 0xb1, 0x7f, 0x00, 0x2e, 0x41, 0x40, 0x00, 0x40, 0x48, 0x04, 0x98, 0x2e, 0x74, 0xc0, 0x1e, 0xaa, 0xd3, 0x6f,
    0x14, 0x30, 0xb1, 0x6f, 0xe3, 0x22, 0xc0, 0x6f, 0x52, 0x40, 0xe4, 0x6f, 0x4c, 0x0e, 0x12, 0x42, 0xd3, 0x7f, 0xeb,
    0x2f, 0x03, 0x2e, 0x86, 0x0f, 0x40, 0x90, 0x11, 0x30, 0x03, 0x2f, 0x23, 0x2e, 0x86, 0x0f, 0x02, 0x2c, 0x00, 0x30,
    0xd0, 0x6f, 0xfb, 0x6f, 0xb0, 0x5f, 0xb8, 0x2e, 0x40, 0x50, 0xf1, 0x7f, 0x0a, 0x25, 0x3c, 0x86, 0xeb, 0x7f, 0x41,
    0x33, 0x22, 0x30, 0x98, 0x2e, 0xc2, 0xc4, 0xd3, 0x6f, 0xf4, 0x30, 0xdc, 0x09, 0x47, 0x58, 0xc2, 0x6f, 0x94, 0x09,
    0xeb, 0x58, 0x6a, 0xbb, 0xdc, 0x08, 0xb4, 0xb9, 0xb1, 0xbd, 0xe9, 0x5a, 0x95, 0x08, 0x21, 0xbd, 0xf6, 0xbf, 0x77,
    0x0b, 0x51, 0xbe, 0xf1, 0x6f, 0xeb, 0x6f, 0x52, 0x42, 0x54, 0x42, 0xc0, 0x2e, 0x43, 0x42, 0xc0, 0x5f, 0x50, 0x50,
    0xf5, 0x50, 0x31, 0x30, 0x11, 0x42, 0xfb, 0x7f, 0x7b, 0x30, 0x0b, 0x42, 0x11, 0x30, 0x02, 0x80, 0x23, 0x33, 0x01,
    0x42, 0x03, 0x00, 0x07, 0x2e, 0x80, 0x03, 0x05, 0x2e, 0xd3, 0x00, 0x23, 0x52, 0xe2, 0x7f, 0xd3, 0x7f, 0xc0, 0x7f,
    0x98, 0x2e, 0xb6, 0x0e, 0xd1, 0x6f, 0x08, 0x0a, 0x1a, 0x25, 0x7b, 0x86, 0xd0, 0x7f, 0x01, 0x33, 0x12, 0x30, 0x98,
    0x2e, 0xc2, 0xc4, 0xd1, 0x6f, 0x08, 0x0a, 0x00, 0xb2, 0x0d, 0x2f, 0xe3, 0x6f, 0x01, 0x2e, 0x80, 0x03, 0x51, 0x30,
    0xc7, 0x86, 0x23, 0x2e, 0x21, 0xf2, 0x08, 0xbc, 0xc0, 0x42, 0x98, 0x2e, 0xa5, 0xb7, 0x00, 0x2e, 0x00, 0x2e, 0xd0,
    0x2e, 0xb0, 0x6f, 0x0b, 0xb8, 0x03, 0x2e, 0x1b, 0x00, 0x08, 0x1a, 0xb0, 0x7f, 0x70, 0x30, 0x04, 0x2f, 0x21, 0x2e,
    0x21, 0xf2, 0x00, 0x2e, 0x00, 0x2e, 0xd0, 0x2e, 0x98, 0x2e, 0x6d, 0xc0, 0x98, 0x2e, 0x5d, 0xc0, 0xed, 0x50, 0x98,
    0x2e, 0x44, 0xcb, 0xef, 0x50, 0x98, 0x2e, 0x46, 0xc3, 0xf1, 0x50, 0x98, 0x2e, 0x53, 0xc7, 0x35, 0x50, 0x98, 0x2e,
    0x64, 0xcf, 0x10, 0x30, 0x98, 0x2e, 0xdc, 0x03, 0x20, 0x26, 0xc0, 0x6f, 0x02, 0x31, 0x12, 0x42, 0xab, 0x33, 0x0b,
    0x42, 0x37, 0x80, 0x01, 0x30, 0x01, 0x42, 0xf3, 0x37, 0xf7, 0x52, 0xfb, 0x50, 0x44, 0x40, 0xa2, 0x0a, 0x42, 0x42,
    0x8b, 0x31, 0x09, 0x2e, 0x5e, 0xf7, 0xf9, 0x54, 0xe3, 0x08, 0x83, 0x42, 0x1b, 0x42, 0x23, 0x33, 0x4b, 0x00, 0xbc,
    0x84, 0x0b, 0x40, 0x33, 0x30, 0x83, 0x42, 0x0b, 0x42, 0xe0, 0x7f, 0xd1, 0x7f, 0x98, 0x2e, 0x58, 0xb7, 0xd1, 0x6f,
    0x80, 0x30, 0x40, 0x42, 0x03, 0x30, 0xe0, 0x6f, 0xf3, 0x54, 0x04, 0x30, 0x00, 0x2e, 0x00, 0x2e, 0x01, 0x89, 0x62,
    0x0e, 0xfa, 0x2f, 0x43, 0x42, 0x11, 0x30, 0xfb, 0x6f, 0xc0, 0x2e, 0x01, 0x42, 0xb0, 0x5f, 0xc1, 0x4a, 0x00, 0x00,
    0x6d, 0x57, 0x00, 0x00, 0x77, 0x8e, 0x00, 0x00, 0xe0, 0xff, 0xff, 0xff, 0xd3, 0xff, 0xff, 0xff, 0xe5, 0xff, 0xff,
    0xff, 0xee, 0xe1, 0xff, 0xff, 0x7c, 0x13, 0x00, 0x00, 0x46, 0xe6, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x2e, 0x00, 0xc1, 0x80,
    0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
    0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00,
    0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e,
    0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80,
    0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
    0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00,
    0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e,
    0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80,
    0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
    0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00,
    0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e,
    0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80,
    0x2e, 0x00, 0xc1
};

int bmi_get_chipid(void) {
    uint8_t reg_id = 0x00;
    uint8_t tmp;

    bmi_i2c_read(I2C_NUM_0, &reg_id, &tmp, 1);
    printf("valor de CHIPID: %2X \n\n", tmp);

    if (tmp == 0x24) {
        printf("Chip BMI270 reconocido.\n\n");
        return 1;
    } else {
        printf("Chip BMI270 no reconocido. \nCHIP ID: %2x\n\n", tmp);  // %2X
    }

    return 0;
}

void bmi_softreset(void) {
    uint8_t reg_softreset = 0x7E, val_softreset = 0xB6;

    ret = bmi_i2c_write(I2C_NUM_0, &reg_softreset, &val_softreset, 1);
    vTaskDelay(1000 / portTICK_PERIOD_MS);
    if (ret != ESP_OK) {
        printf("\nError en softreset: %s \n", esp_err_to_name(ret));
    } else {
        printf("\nSoftreset: OK\n\n");
    }
}

void bmi_initialization(void) {
    uint8_t reg_pwr_conf_advpowersave = 0x7C, val_pwr_conf_advpowersave = 0x00;
    uint8_t reg_init_ctrl = 0x59, val_init_ctrl = 0x00, val_init_ctrl2 = 0x01;
    uint8_t reg_init_data = 0x5E; //, tmp;

    printf("Inicializando ...\n");

    bmi_i2c_write(I2C_NUM_0, &reg_pwr_conf_advpowersave, &val_pwr_conf_advpowersave, 1);

    vTaskDelay(1000 / portTICK_PERIOD_MS);

    ret = bmi_i2c_write(I2C_NUM_0, &reg_init_ctrl, &val_init_ctrl, 1);
    int config_size = sizeof(bmi270_config_file);

    ret = bmi_i2c_write(I2C_NUM_0, &reg_init_data, (uint8_t *)bmi270_config_file, config_size);
    if (ret != ESP_OK) {
        printf("\nError cargando config_file\n");
    } else {
        printf("\nConfig_file cargado.\n");
    }

    vTaskDelay(1000 / portTICK_PERIOD_MS);

    ret = bmi_i2c_write(I2C_NUM_0, &reg_init_ctrl, &val_init_ctrl2, 1);

    printf("\nAlgoritmo de inicializacion finalizado.\n\n");
}

void bmi_check_initialization(void) {
    uint8_t reg_internalstatus = 0x21;
    uint8_t tmp;

    vTaskDelay(1000 / portTICK_PERIOD_MS);

    bmi_i2c_read(I2C_NUM_0, &reg_internalstatus, &tmp, 1);
    printf("Init_status.0: %x \n", (tmp & 0b00001111));
    if ((tmp & 0b00001111) == 1) {
        printf("Comprobacion Inicializacion: OK\n\n");
    } else {
        printf("Inicializacion fallida\n\n");
        exit(EXIT_SUCCESS);
    }
}

// these are the available values for the ODR of the accelerometer
// this represents the 4 least significant bits of the ACC_CONF register
uint8_t acc_odr_values[16] = {
    0x00, // Reserved 
    0x01, // 0.78125 Hz
    0x02, // 1.5625 Hz
    0x03, // 3.125 Hz
    0x04, // 6.25 Hz
    0x05, // 12.5 Hz
    0x06, // 25 Hz
    0x07, // 50 Hz
    0x08, // 100 Hz
    0x09, // 200 Hz
    0x0A, // 400 Hz
    0x0B, // 800 Hz
    0x0C, // 1600 Hz
    0x0D, // Reserved
    0x0E, // Reserved
    0x0F  // Reserved
};

// these are the available values for the range of the accelerometer
// this represents the 2 least significant bits of the ACC_RANGE register
uint8_t acc_range_values[4] = {
    0x00, // +/- 2g
    0x01, // +/- 4g
    0x02, // +/- 8g
    0x03  // +/- 16g
};

// these are the numbers for converting the accelerometer data to m/s^2
float acc_range_values_m_s2[4] = {
    19.6133, // +/- 2g, 1g = 9.80665 m/s^2, alcance max: 19.6133 m/s^2
    39.2266, // +/- 4g, 1g = 9.80665 m/s^2, alcance max: 39.2266 m/s^2
    78.4532, // +/- 8g, 1g = 9.80665 m/s^2, alcance max: 78.4532 m/s^2
    156.9064 // +/- 16g, 1g = 9.80665 m/s^2, alcance max: 156.9064 m/s^2
};

// these are the numbers for converting the accelerometer data to g
float acc_range_values_g[4] = {
    2.000, // +/- 2g, 1g = 1g, alcance max: 2g
    4.000, // +/- 4g, 1g = 1g, alcance max: 4g
    8.000, // +/- 8g, 1g = 1g, alcance max: 8g
    16.000 // +/- 16g, 1g = 1g, alcance max: 16g
};

// these are the available values for the ODR of the gyroscope
// this represents the 4 least significant bits of the GYR_CONF register
uint8_t gyr_odr_values[16] = {
    0x00, // Reserved
    0x01, // Reserved
    0x02, // Reserved
    0x03, // Reserved
    0x04, // Reserved
    0x05, // Reserved
    0x06, // 25 Hz
    0x07, // 50 Hz
    0x08, // 100 Hz
    0x09, // 200 Hz
    0x0A, // 400 Hz
    0x0B, // 800 Hz
    0x0C, // 1600 Hz
    0x0D, // 3200 Hz
    0x0E, // Reserved
    0x0F  // Reserved
};

// these are the available values for the range of the gyroscope
// this represents the 3 least significant bits of the GYR_RANGE register
uint8_t gyr_range_values[8] = {
    0x00, // +/- 2000 dps, 16.4LSB/dps
    0x01, // +/- 1000 dps, 32.8LSB/dps
    0x02, // +/- 500 dps, 65.6LSB/dps
    0x03, // +/- 250 dps, 131.2LSB/dps
    0x04, // +/- 125 dps, 262.4LSB/dps
    0x05, // Reserved
    0x06, // Reserved
    0x07  // Reserved
};

// these are the numbers for converting the gyroscope data to rad/ss
float gyr_range_values_rad_s[8] = {
    34.90659, // +/- 2000 dps, 1 dps = 0.0174533 rad/s, alcance max: 34.90659 rad/s
    17.4533, // +/- 1000 dps, 1 dps = 0.0174533 rad/s, alcance max: 17.4533 rad/s
    8.72665, // +/- 500 dps, 1 dps = 0.0174533 rad/s, alcance max: 8.72665 rad/s
    4.36332, // +/- 250 dps, 1 dps = 0.0174533 rad/s, alcance max: 4.36332 rad/s
    2.18166, // +/- 125 dps, 1 dps = 0.0174533 rad/s, alcance max: 2.18166 rad/s
    0, // Reserved
    0, // Reserved
    0  // Reserved
};

void bmi_supend_mode(void) {
    // PWR_CTRL: disable auxiliary sensor, gyro, acc and temp
    // PWR_CONF: disable fup_en and fifo_self_wake_up, enable adv_power_save

    uint8_t reg_pwr_ctrl = 0x7D, val_pwr_ctrl = 0x00;
    uint8_t reg_pwr_conf = 0x7C, val_pwr_conf = 0x01;

    bmi_i2c_write(I2C_NUM_0, &reg_pwr_ctrl, &val_pwr_ctrl, 1);
    bmi_i2c_write(I2C_NUM_0, &reg_pwr_conf, &val_pwr_conf, 1);

    vTaskDelay(1000 / portTICK_PERIOD_MS);

    printf("Modo de suspension: activado. \n\n");
}

void bmi_low_power_mode(uint8_t acc_odr, uint8_t acc_range) {
    // PWR_CTRL: disable auxiliary sensor, gyro and temp, enable acc 
    // ACC_CONF: _Hz en datos acc, filter: power optimized, acc_bwp: osr2_avg2
    // ACC_RANGE: acc_range +/-8g (1g = 9.80665 m/s2, alcance max: 78.4532 m/s2, 16 bit= 65536 => 1bit = 78.4532/32768 m/s2)
    // PWR_CONF: disable fup_en, enable adv_power_save, fifo_self_wake_up

    uint8_t reg_pwr_ctrl = 0x7D, val_pwr_ctrl = 0x04;
    uint8_t reg_acc_conf = 0x40, val_acc_conf = 0x10 | acc_odr ; // val_acc_conf = 0b00010000 | 0b0000____
    uint8_t reg_acc_range = 0x41, val_acc_range = 0x00 | acc_range; // val_acc_range = 0b00000000 | 0b000000__
    uint8_t reg_pwr_conf = 0x7C, val_pwr_conf = 0x03;

    bmi_i2c_write(I2C_NUM_0, &reg_pwr_ctrl, &val_pwr_ctrl, 1);
    bmi_i2c_write(I2C_NUM_0, &reg_acc_conf, &val_acc_conf, 1);
    bmi_i2c_write(I2C_NUM_0, &reg_acc_range, &val_acc_range, 1);
    bmi_i2c_write(I2C_NUM_0, &reg_pwr_conf, &val_pwr_conf, 1);

    vTaskDelay(1000 / portTICK_PERIOD_MS);

    printf("Modo de bajo consumo: activado. \n\n");
}

void bmi_normal_power_mode(uint8_t acc_odr, uint8_t acc_range, uint8_t gyr_odr, uint8_t gyr_range) {
    // PWR_CTRL: disable auxiliary sensor, enbale gryo, temp and acc 
    // ACC_CONF: _Hz en datos acc, filter: performance optimized, acc_bwp: norm_avg4
    // ACC_RANGE: acc_range +/-8g (1g = 9.80665 m/s2, alcance max: 78.4532 m/s2, 16 bit= 65536 => 1bit = 78.4532/32768 m/s2)
    // GYR_CONF: _Hz en datos gyro, noise filter: power optimized, filter: performance optimized, gyr_bwp: norm
    // GYR_RANGE: +/-2000dps, 16.4LSB/dps (1 bit= 2000/32768 dps, 34.90659/32768 rad/s)
    // PWR_CONF: disable fup_en, adv_power_save, enable fifo_self_wake_up

    uint8_t reg_pwr_ctrl = 0x7D, val_pwr_ctrl = 0x0E;
    uint8_t reg_acc_conf = 0x40, val_acc_conf = 0xA0| acc_odr; // val_acc_conf = 0b10100000 | 0b0000____
    uint8_t reg_acc_range = 0x41, val_acc_range = 0x00 | acc_range; // val_acc_range = 0b000000000 | 0b000000__
    uint8_t reg_gyr_conf = 0x42, val_gyr_conf = 0xA0 | gyr_odr; // val_gyr_conf = 0b10100000 | 0b0000____
    uint8_t reg_gyr_range = 0x43, val_gyr_range = 0x00 | gyr_range; // val_gyr_range = 0b00000000 | 0b00000___
    uint8_t reg_pwr_conf = 0x7C, val_pwr_conf = 0x02;

    bmi_i2c_write(I2C_NUM_0, &reg_pwr_ctrl, &val_pwr_ctrl, 1);
    bmi_i2c_write(I2C_NUM_0, &reg_acc_conf, &val_acc_conf, 1);
    bmi_i2c_write(I2C_NUM_0, &reg_acc_range, &val_acc_range, 1);
    bmi_i2c_write(I2C_NUM_0, &reg_gyr_conf, &val_gyr_conf, 1);
    bmi_i2c_write(I2C_NUM_0, &reg_gyr_range, &val_gyr_range, 1);
    bmi_i2c_write(I2C_NUM_0, &reg_pwr_conf, &val_pwr_conf, 1);

    vTaskDelay(1000 / portTICK_PERIOD_MS);

    printf("Modo de potencia normal: activado. \n\n");
}

void bmi_performance_power_mode(uint8_t acc_odr, uint8_t acc_range, uint8_t gyr_odr, uint8_t gyr_range) {
    // PWR_CTRL: disable auxiliary sensor, enbale gryo, temp and acc
    // ACC_CONF: _Hz en datos acc, filter: performance optimized, acc_bwp: osr4_avg4
    // ACC_RANGE: acc_range +/-8g (1g = 9.80665 m/s2, alcance max: 78.4532 m/s2, 16 bit= 65536 => 1bit = 78.4532/32768 m/s2)
    // GYR_CONF: _Hz en datos gyro, noise filter: performance optimized, filter: performance optimized, gyr_bwp: norm
    // GYR_RANGE: +/-2000dps, 16.4LSB/dps (1 bit= 2000/32768 dps, 34.90659/32768 rad/s)
    // PWR_CONF: disable fup_en, adv_power_save, enable fifo_self_wake_up

    uint8_t reg_pwr_ctrl = 0x7D, val_pwr_ctrl = 0x0E;
    uint8_t reg_acc_conf = 0x40, val_acc_conf = 0xA0| acc_odr; // val_acc_conf = 0b10100000 | 0b0000____
    uint8_t reg_acc_range = 0x41, val_acc_range = 0x00 | acc_range; // val_acc_range = 0b000000000 | 0b000000__
    uint8_t reg_gyr_conf = 0x42, val_gyr_conf = 0xE0 | gyr_odr; // val_gyr_conf = 0b11100000 | 0b0000____
    uint8_t reg_gyr_range = 0x43, val_gyr_range = 0x00 | gyr_range; // val_gyr_range = 0b00000000 | 0b00000___
    uint8_t reg_pwr_conf = 0x7C, val_pwr_conf = 0x02;

    bmi_i2c_write(I2C_NUM_0, &reg_pwr_ctrl, &val_pwr_ctrl, 1);
    bmi_i2c_write(I2C_NUM_0, &reg_acc_conf, &val_acc_conf, 1);
    bmi_i2c_write(I2C_NUM_0, &reg_acc_range, &val_acc_range, 1);
    bmi_i2c_write(I2C_NUM_0, &reg_gyr_conf, &val_gyr_conf, 1);
    bmi_i2c_write(I2C_NUM_0, &reg_gyr_range, &val_gyr_range, 1);
    bmi_i2c_write(I2C_NUM_0, &reg_pwr_conf, &val_pwr_conf, 1);

    vTaskDelay(1000 / portTICK_PERIOD_MS);

    printf("Modo de potencia de rendimiento: activado. \n\n");
}

void bmi_internal_status(void) {
    uint8_t reg_internalstatus = 0x21;
    uint8_t tmp;

    bmi_i2c_read(I2C_NUM_0, &reg_internalstatus, &tmp, 1);
    printf("Internal Status: %2X\n\n", tmp);
}

void accel_m_s2_data(uint16_t *acc_x_array, uint16_t *acc_y_array, uint16_t *acc_z_array, int window_size, float to_m_s2_multiplier) {
    printf("Datos de aceleraciÃ³n en m/s2\n");

    // arrays are created with malloc to store the data in m/s2
    float *acc_x_m_s2 = (float *)malloc(window_size * sizeof(float));
    float *acc_y_m_s2 = (float *)malloc(window_size * sizeof(float));
    float *acc_z_m_s2 = (float *)malloc(window_size * sizeof(float));

    // the data is added to the arrays in m/s2
    for (int i = 0; i < window_size; i++) {
        acc_x_m_s2[i] = (int16_t)acc_x_array[i] * to_m_s2_multiplier;
        acc_y_m_s2[i] = (int16_t)acc_y_array[i] * to_m_s2_multiplier;
        acc_z_m_s2[i] = (int16_t)acc_z_array[i] * to_m_s2_multiplier;
    }

    // the data of the acc_x array is printed in m/s2
    for (int i = 0; i < window_size; i++) {
        printf("[Acc m/s2] Lectura %d: acc_x: %f m/s2\n", i+1 , acc_x_m_s2[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }

    // the data of the acc_y array is printed in m/s2
    for (int i = 0; i < window_size; i++) {
        printf("[Acc m/s2] Lectura %d: acc_y: %f m/s2\n", i+1 , acc_y_m_s2[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }

    // the data of the acc_z array is printed in m/s2
    for (int i = 0; i < window_size; i++) {
        printf("[Acc m/s2] Lectura %d: acc_z: %f m/s2\n", i+1 , acc_z_m_s2[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }

    printf("Fin de los datos de aceleraciÃ³n en m/s2\n");

    printf("Datos de la FFT\n");

    // arrays are created with malloc to store the FFTx data, real and imaginary
    float *FFTx_re = (float *)malloc(window_size * sizeof(float));
    float *FFTx_im = (float *)malloc(window_size * sizeof(float));

    printf("Calculando FFTx...\n");

    // the FFTx is calculated and stored in the array
    calcularFFT(acc_x_m_s2, window_size, FFTx_re, FFTx_im);

    // the data of the FFTx_re array is printed
    for (int i = 0; i < window_size; i++) {
        printf("[Acc m/s2] Dato %d: FFTx_RE: %f\n", i+1 , FFTx_re[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }

    // the data of the FFTx_im array is printed
    for (int i = 0; i < window_size; i++) {
        printf("[Acc m/s2] Dato %d: FFTx_IM: %f\n", i+1 , FFTx_im[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }

    // the arrays are freed
    free(FFTx_re);
    free(FFTx_im);

    // arrays are created with malloc to store the FFTy data, real and imaginary
    float *FFTy_re = (float *)malloc(window_size * sizeof(float));
    float *FFTy_im = (float *)malloc(window_size * sizeof(float));

    printf("Calculando FFTy...\n");

    // the FFTy is calculated and stored in the array
    calcularFFT(acc_y_m_s2, window_size, FFTy_re, FFTy_im);

    // the data of the FFTy_re array is printed
    for (int i = 0; i < window_size; i++) {
        printf("[Acc m/s2] Dato %d: FFTy_RE: %f\n", i+1 , FFTy_re[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }

    // the data of the FFTy_im array is printed
    for (int i = 0; i < window_size; i++) {
        printf("[Acc m/s2] Dato %d: FFTy_IM: %f\n", i+1 , FFTy_im[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }

    // the arrays are freed
    free(FFTy_re);
    free(FFTy_im);

    // arrays are created with malloc to store the FFTz data, real and imaginary
    float *FFTz_re = (float *)malloc(window_size * sizeof(float));
    float *FFTz_im = (float *)malloc(window_size * sizeof(float));

    printf("Calculando FFTz...\n");

    // the FFTz is calculated and stored in the array
    calcularFFT(acc_z_m_s2, window_size, FFTz_re, FFTz_im);

    // the data of the FFTz_re array is printed
    for (int i = 0; i < window_size; i++) {
        printf("[Acc m/s2] Dato %d: FFTz_RE: %f\n", i+1 , FFTz_re[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }

    // the data of the FFTz_im array is printed
    for (int i = 0; i < window_size; i++) {
        printf("[Acc m/s2] Dato %d: FFTz_IM: %f\n", i+1 , FFTz_im[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }

    // the arrays are freed
    free(FFTz_re);
    free(FFTz_im);

    printf("Fin de los datos de la FFT\n");

    // float that stores the RMSx up to the i-th data
    float RMSx = 0;
    // float that stores the RMSy up to the i-th data
    float RMSy = 0;
    // float that stores the RMSz up to the i-th data
    float RMSz = 0;
    // arrays are created with malloc to store the RMS data
    float *RMSx_array = (float *)malloc(window_size * sizeof(float));
    float *RMSy_array = (float *)malloc(window_size * sizeof(float));
    float *RMSz_array = (float *)malloc(window_size * sizeof(float));

    // the RMSx is calculated up to the i-th data and stored in the array
    for (int i = 0; i < window_size; i++) {
        RMSx += pow(acc_x_m_s2[i], 2);
        RMSx_array[i] = sqrt(RMSx/(i+1));
    }
    
    // the RMSy is calculated up to the i-th data and stored in the array
    for (int i = 0; i < window_size; i++) {
        RMSy += pow(acc_y_m_s2[i], 2);
        RMSy_array[i] = sqrt(RMSy/(i+1));
    }

    // the RMSz is calculated up to the i-th data and stored in the array
    for (int i = 0; i < window_size; i++) {
        RMSz += pow(acc_z_m_s2[i], 2);
        RMSz_array[i] = sqrt(RMSz/(i+1));
    }

    printf("Datos de RMS\n");

    // the RMSx data is printed
    for (int i = 0; i < window_size; i++) {
        printf("[Acc m/s2] Dato %d: RMSx: %f\n", i+1 , RMSx_array[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }

    // the RMSy data is printed
    for (int i = 0; i < window_size; i++) {
        printf("[Acc m/s2] Dato %d: RMSy: %f\n", i+1 , RMSy_array[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }

    // the RMSz data is printed
    for (int i = 0; i < window_size; i++) {
        printf("[Acc m/s2] Dato %d: RMSz: %f\n", i+1 , RMSz_array[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }

    printf("Fin de los datos de RMS\n");

    printf("Datos de los 5 valores mÃ¡s altos de RMS\n");

    // arrays are created with malloc to store the top 5 RMS data
    float *top_5_RMSx = (float *)malloc(5 * sizeof(float));
    float *top_5_RMSy = (float *)malloc(5 * sizeof(float));
    float *top_5_RMSz = (float *)malloc(5 * sizeof(float));

    printf("Calculando los 5 valores mÃ¡s altos de RMSx...\n");

    // the top 5 RMSx values are stored in the array
    save_top_5(RMSx_array, window_size, top_5_RMSx);

    // the data of the top_5_RMSx array is printed
    for (int i = 0; i < 5; i++) {
        printf("[Acc m/s2] Top %d: RMSx: %f\n", i+1 , top_5_RMSx[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }

    // the arrays are freed
    free(top_5_RMSx);
    free(RMSx_array);

    printf("Calculando los 5 valores mÃ¡s altos de RMSy...\n");

    // the top 5 RMSy values are stored in the array
    save_top_5(RMSy_array, window_size, top_5_RMSy);

    // the data of the top_5_RMSy array is printed
    for (int i = 0; i < 5; i++) {
        printf("[Acc m/s2] Top %d: RMSy: %f\n", i+1 , top_5_RMSy[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }

    // the arrays are freed
    free(top_5_RMSy);
    free(RMSy_array);

    printf("Calculando los 5 valores mÃ¡s altos de RMSz...\n");

    // the top 5 RMSz values are stored in the array
    save_top_5(RMSz_array, window_size, top_5_RMSz);

    // the data of the top_5_RMSz array is printed
    for (int i = 0; i < 5; i++) {
        printf("[Acc m/s2] Top %d: RMSz: %f\n", i+1 , top_5_RMSz[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }

    // the arrays are freed
    free(top_5_RMSz);
    free(RMSz_array);

    printf("Fin de los datos de los 5 valores mÃ¡s altos de RMS\n");

    printf("Datos de los 5 valores mÃ¡s altos de aceleraciÃ³n en m/s2\n");

    // arrays are created with malloc to store the top 5 acc_x data
    float *top_5_acc_x = (float *)malloc(5 * sizeof(float));
    float *top_5_acc_y = (float *)malloc(5 * sizeof(float));
    float *top_5_acc_z = (float *)malloc(5 * sizeof(float));

    printf("Calculando los 5 valores mÃ¡s altos de acc_x...\n");

    // the top 5 acc_x values are stored in the array
    save_top_5(acc_x_m_s2, window_size, top_5_acc_x);

    // the data of the top_5_acc_x array is printed
    for (int i = 0; i < 5; i++) {
        printf("[Acc m/s2] Top %d: acc_x: %f m/s2\n", i+1 , top_5_acc_x[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }

    // the arrays are freed
    free(top_5_acc_x);
    free(acc_x_m_s2);

    printf("Calculando los 5 valores mÃ¡s altos de acc_y...\n");

    // the top 5 acc_y values are stored in the array
    save_top_5(acc_y_m_s2, window_size, top_5_acc_y);

    // the data of the top_5_acc_y array is printed
    for (int i = 0; i < 5; i++) {
        printf("[Acc m/s2] Top %d: acc_y: %f m/s2\n", i+1 , top_5_acc_y[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }

    // the arrays are freed
    free(top_5_acc_y);
    free(acc_y_m_s2);

    printf("Calculando los 5 valores mÃ¡s altos de acc_z...\n");

    // the top 5 acc_z values are stored in the array
    save_top_5(acc_z_m_s2, window_size, top_5_acc_z);

    // the data of the top_5_acc_z array is printed
    for (int i = 0; i < 5; i++) {
        printf("[Acc m/s2] Top %d: acc_z: %f m/s2\n", i+1 , top_5_acc_z[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }

    // the arrays are freed
    free(top_5_acc_z);
    free(acc_z_m_s2);

    printf("Fin de los datos de los 5 valores mÃ¡s altos de aceleraciÃ³n en m/s2\n");

    printf("Fin de los datos de aceleraciÃ³n en m/s2\n\n");
}

void accel_g_data(uint16_t *acc_x_array, uint16_t *acc_y_array, uint16_t *acc_z_array, int window_size, float to_g_multiplier) {
    printf("Datos de aceleraciÃ³n en g\n");

    // arrays are created with malloc to store the data in g
    float *acc_x_g = (float *)malloc(window_size * sizeof(float));
    float *acc_y_g = (float *)malloc(window_size * sizeof(float));
    float *acc_z_g = (float *)malloc(window_size * sizeof(float));

    // the data is added to the arrays in g
    for (int i = 0; i < window_size; i++) {
        acc_x_g[i] = (int16_t)acc_x_array[i] * to_g_multiplier;
        acc_y_g[i] = (int16_t)acc_y_array[i] * to_g_multiplier;
        acc_z_g[i] = (int16_t)acc_z_array[i] * to_g_multiplier;
    }

    // the data of the acc_x array is printed in g
    for (int i = 0; i < window_size; i++) {
        printf("[Acc g] Lectura %d: acc_x: %f g\n", i+1 , acc_x_g[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }

    // the data of the acc_y array is printed in g
    for (int i = 0; i < window_size; i++) {
        printf("[Acc g] Lectura %d: acc_y: %f g\n", i+1 , acc_y_g[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }

    // the data of the acc_z array is printed in g
    for (int i = 0; i < window_size; i++) {
        printf("[Acc g] Lectura %d: acc_z: %f g\n", i+1 , acc_z_g[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }

    printf("Fin de los datos de aceleraciÃ³n en g\n");

    printf("Datos de la FFT\n");

    // arrays are created with malloc to store the FFTx data, real and imaginary
    float *FFTx_re = (float *)malloc(window_size * sizeof(float));
    float *FFTx_im = (float *)malloc(window_size * sizeof(float));

    printf("Calculando FFTx...\n");

    // the FFTx is calculated and stored in the array
    calcularFFT(acc_x_g, window_size, FFTx_re, FFTx_im);
    
    // the data of the FFTx_re array is printed
    for (int i = 0; i < window_size; i++) {
        printf("[Acc g] Dato %d: FFTx_RE: %f\n", i+1 , FFTx_re[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }

    // the data of the FFTx_im array is printed
    for (int i = 0; i < window_size; i++) {
        printf("[Acc g] Dato %d: FFTx_IM: %f\n", i+1 , FFTx_im[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }

    // the arrays are freed
    free(FFTx_re);
    free(FFTx_im);

    // arrays are created with malloc to store the FFTy data, real and imaginary
    float *FFTy_re = (float *)malloc(window_size * sizeof(float));
    float *FFTy_im = (float *)malloc(window_size * sizeof(float));

    printf("Calculando FFTy...\n");

    // the FFTy is calculated and stored in the array
    calcularFFT(acc_y_g, window_size, FFTy_re, FFTy_im);

    // the data of the FFTy_re array is printed
    for (int i = 0; i < window_size; i++) {
        printf("[Acc g] Dato %d: FFTy_RE: %f\n", i+1 , FFTy_re[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }

    // the data of the FFTy_im array is printed
    for (int i = 0; i < window_size; i++) {
        printf("[Acc g] Dato %d: FFTy_IM: %f\n", i+1 , FFTy_im[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }

    // the arrays are freed
    free(FFTy_re);
    free(FFTy_im);

    // arrays are created with malloc to store the FFTz data, real and imaginary
    float *FFTz_re = (float *)malloc(window_size * sizeof(float));
    float *FFTz_im = (float *)malloc(window_size * sizeof(float));

    printf("Calculando FFTz...\n");

    // the FFTz is calculated and stored in the array
    calcularFFT(acc_z_g, window_size, FFTz_re, FFTz_im);

    // the data of the FFTz_re array is printed
    for (int i = 0; i < window_size; i++) {
        printf("[Acc g] Dato %d: FFTz_RE: %f\n", i+1 , FFTz_re[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }

    // the data of the FFTz_im array is printed
    for (int i = 0; i < window_size; i++) {
        printf("[Acc g] Dato %d: FFTz_IM: %f\n", i+1 , FFTz_im[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }

    // the arrays are freed
    free(FFTz_re);
    free(FFTz_im);

    printf("Fin de los datos de la FFT\n");

    // float that stores the RMSx up to the i-th data
    float RMSx = 0;
    // float that stores the RMSy up to the i-th data
    float RMSy = 0;
    // float that stores the RMSz up to the i-th data
    float RMSz = 0;
    // arrays are created with malloc to store the RMS data
    float *RMSx_array = (float *)malloc(window_size * sizeof(float));
    float *RMSy_array = (float *)malloc(window_size * sizeof(float));
    float *RMSz_array = (float *)malloc(window_size * sizeof(float));

    // the RMSx is calculated up to the i-th data and stored in the array
    for (int i = 0; i < window_size; i++) {
        RMSx += pow(acc_x_g[i], 2);
        RMSx_array[i] = sqrt(RMSx/(i+1));
    }

    // the RMSy is calculated up to the i-th data and stored in the array
    for (int i = 0; i < window_size; i++) {
        RMSy += pow(acc_y_g[i], 2);
        RMSy_array[i] = sqrt(RMSy/(i+1));
    }

    // the RMSz is calculated up to the i-th data and stored in the array
    for (int i = 0; i < window_size; i++) {
        RMSz += pow(acc_z_g[i], 2);
        RMSz_array[i] = sqrt(RMSz/(i+1));
    }

    printf("Datos de RMS\n");

    // the RMSx data is printed
    for (int i = 0; i < window_size; i++) {
        printf("[Acc g] Dato %d: RMSx: %f\n", i+1 , RMSx_array[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }

    // the RMSy data is printed
    for (int i = 0; i < window_size; i++) {
        printf("[Acc g] Dato %d: RMSy: %f\n", i+1 , RMSy_array[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }

    // the RMSz data is printed
    for (int i = 0; i < window_size; i++) {
        printf("[Acc g] Dato %d: RMSz: %f\n", i+1 , RMSz_array[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }

    printf("Fin de los datos de RMS\n");

    printf("Datos de los 5 valores mÃ¡s altos de RMS\n");

    // arrays are created with malloc to store the top 5 RMS data
    float *top_5_RMSx = (float *)malloc(5 * sizeof(float));
    float *top_5_RMSy = (float *)malloc(5 * sizeof(float));
    float *top_5_RMSz = (float *)malloc(5 * sizeof(float));

    printf("Calculando los 5 valores mÃ¡s altos de RMSx...\n");

    // the top 5 RMSx values are stored in the array
    save_top_5(RMSx_array, window_size, top_5_RMSx);

    // the data of the top_5_RMSx array is printed
    for (int i = 0; i < 5; i++) {
        printf("[Acc g] Top %d: RMSx: %f\n", i+1 , top_5_RMSx[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }

    // the arrays are freed
    free(top_5_RMSx);
    free(RMSx_array);

    printf("Calculando los 5 valores mÃ¡s altos de RMSy...\n");

    // the top 5 RMSy values are stored in the array
    save_top_5(RMSy_array, window_size, top_5_RMSy);

    // the data of the top_5_RMSy array is printed
    for (int i = 0; i < 5; i++) {
        printf("[Acc g] Top %d: RMSy: %f\n", i+1 , top_5_RMSy[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }

    // the arrays are freed
    free(top_5_RMSy);
    free(RMSy_array);

    printf("Calculando los 5 valores mÃ¡s altos de RMSz...\n");

    // the top 5 RMSz values are stored in the array
    save_top_5(RMSz_array, window_size, top_5_RMSz);

    // the data of the top_5_RMSz array is printed
    for (int i = 0; i < 5; i++) {
        printf("[Acc g] Top %d: RMSz: %f\n", i+1 , top_5_RMSz[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }

    // the arrays are freed
    free(top_5_RMSz);
    free(RMSz_array);

    printf("Fin de los datos de los 5 valores mÃ¡s altos de RMS\n");

    printf("Datos de los 5 valores mÃ¡s altos de aceleraciÃ³n en g\n");

    // arrays are created with malloc to store the top 5 acc_x data
    float *top_5_acc_x = (float *)malloc(5 * sizeof(float));
    float *top_5_acc_y = (float *)malloc(5 * sizeof(float));
    float *top_5_acc_z = (float *)malloc(5 * sizeof(float));

    printf("Calculando los 5 valores mÃ¡s altos de acc_x...\n");

    // the top 5 acc_x values are stored in the array
    save_top_5(acc_x_g, window_size, top_5_acc_x);

    // the data of the top_5_acc_x array is printed
    for (int i = 0; i < 5; i++) {
        printf("[Acc g] Top %d: acc_x: %f g\n", i+1 , top_5_acc_x[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }

    // the arrays are freed
    free(top_5_acc_x);
    free(acc_x_g);

    printf("Calculando los 5 valores mÃ¡s altos de acc_y...\n");

    // the top 5 acc_y values are stored in the array
    save_top_5(acc_y_g, window_size, top_5_acc_y);

    // the data of the top_5_acc_y array is printed
    for (int i = 0; i < 5; i++) {
        printf("[Acc g] Top %d: acc_y: %f g\n", i+1 , top_5_acc_y[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }

    // the arrays are freed
    free(top_5_acc_y);
    free(acc_y_g);

    printf("Calculando los 5 valores mÃ¡s altos de acc_z...\n");

    // the top 5 acc_z values are stored in the array
    save_top_5(acc_z_g, window_size, top_5_acc_z);

    // the data of the top_5_acc_z array is printed
    for (int i = 0; i < 5; i++) {
        printf("[Acc g] Top %d: acc_z: %f g\n", i+1 , top_5_acc_z[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }

    // the arrays are freed
    free(top_5_acc_z);
    free(acc_z_g);

    printf("Fin de los datos de los 5 valores mÃ¡s altos de aceleraciÃ³n en g\n");

    printf("Fin de los datos de aceleraciÃ³n en g\n\n");
}

void ang_vel_rad_s_data(uint16_t *gyr_x_array, uint16_t *gyr_y_array, uint16_t *gyr_z_array, int window_size, float to_rad_s_multiplier) {
    printf("Datos de velocidad angular en rad/s\n");

    // arrays are created with malloc to store the data in rad/s
    float *gyr_x_rad_s = (float *)malloc(window_size * sizeof(float));
    float *gyr_y_rad_s = (float *)malloc(window_size * sizeof(float));
    float *gyr_z_rad_s = (float *)malloc(window_size * sizeof(float));

    // the data is added to the arrays in rad/s
    for (int i = 0; i < window_size; i++) {
        gyr_x_rad_s[i] = (int16_t)gyr_x_array[i] * to_rad_s_multiplier;
        gyr_y_rad_s[i] = (int16_t)gyr_y_array[i] * to_rad_s_multiplier;
        gyr_z_rad_s[i] = (int16_t)gyr_z_array[i] * to_rad_s_multiplier;
    }

    // the data of the gyr_x array is printed in rad/s
    for (int i = 0; i < window_size; i++) {
        printf("[Ang_Vel rad/s] Lectura %d: gyr_x: %f rad/s\n", i+1 , gyr_x_rad_s[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }

    // the data of the gyr_y array is printed in rad/s
    for (int i = 0; i < window_size; i++) {
        printf("[Ang_Vel rad/s] Lectura %d: gyr_y: %f rad/s\n", i+1 , gyr_y_rad_s[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }

    // the data of the gyr_z array is printed in rad/s
    for (int i = 0; i < window_size; i++) {
        printf("[Ang_Vel rad/s] Lectura %d: gyr_z: %f rad/s\n", i+1 , gyr_z_rad_s[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);    
    }

    printf("Fin de los datos de velocidad angular en rad/s\n");

    printf("Datos de la FFT\n");

    // arrays are created with malloc to store the FFTx data, real and imaginary
    float *FFTx_re = (float *)malloc(window_size * sizeof(float));
    float *FFTx_im = (float *)malloc(window_size * sizeof(float));

    printf("Calculando FFTx...\n");

    // the FFTx is calculated and stored in the array
    calcularFFT(gyr_x_rad_s, window_size, FFTx_re, FFTx_im);

    // the data of the FFTx_re array is printed
    for (int i = 0; i < window_size; i++) {
        printf("[Ang_Vel rad/s] Dato %d: FFTx_RE: %f\n", i+1 , FFTx_re[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }

    // the data of the FFTx_im array is printed
    for (int i = 0; i < window_size; i++) {
        printf("[Ang_Vel rad/s] Dato %d: FFTx_IM: %f\n", i+1 , FFTx_im[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }

    // the arrays are freed
    free(FFTx_re);
    free(FFTx_im);

    // arrays are created with malloc to store the FFTy data, real and imaginary
    float *FFTy_re = (float *)malloc(window_size * sizeof(float));
    float *FFTy_im = (float *)malloc(window_size * sizeof(float));

    printf("Calculando FFTy...\n");

    // the FFTy is calculated and stored in the array
    calcularFFT(gyr_y_rad_s, window_size, FFTy_re, FFTy_im);

    // the data of the FFTy_re array is printed
    for (int i = 0; i < window_size; i++) {
        printf("[Ang_Vel rad/s] Dato %d: FFTy_RE: %f\n", i+1 , FFTy_re[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }

    // the data of the FFTy_im array is printed
    for (int i = 0; i < window_size; i++) {
        printf("[Ang_Vel rad/s] Dato %d: FFTy_IM: %f\n", i+1 , FFTy_im[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }

    // the arrays are freed
    free(FFTy_re);
    free(FFTy_im);

    // arrays are created with malloc to store the FFTz data, real and imaginary
    float *FFTz_re = (float *)malloc(window_size * sizeof(float));
    float *FFTz_im = (float *)malloc(window_size * sizeof(float));

    printf("Calculando FFTz...\n");

    // the FFTz is calculated and stored in the array
    calcularFFT(gyr_z_rad_s, window_size, FFTz_re, FFTz_im);

    // the data of the FFTz_re array is printed
    for (int i = 0; i < window_size; i++) {
        printf("[Ang_Vel rad/s] Dato %d: FFTz_RE: %f\n", i+1 , FFTz_re[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }

    // the data of the FFTz_im array is printed
    for (int i = 0; i < window_size; i++) {
        printf("[Ang_Vel rad/s] Dato %d: FFTz_IM: %f\n", i+1 , FFTz_im[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }

    // the arrays are freed
    free(FFTz_re);
    free(FFTz_im);

    printf("Fin de los datos de la FFT\n");

    // float that stores the RMSx up to the i-th data
    float RMSx = 0;
    // float that stores the RMSy up to the i-th data
    float RMSy = 0;
    // float that stores the RMSz up to the i-th data
    float RMSz = 0;
    // arrays are created with malloc to store the RMS data
    float *RMSx_array = (float *)malloc(window_size * sizeof(float));
    float *RMSy_array = (float *)malloc(window_size * sizeof(float));
    float *RMSz_array = (float *)malloc(window_size * sizeof(float));

    // the RMSx is calculated up to the i-th data and stored in the array
    for (int i = 0; i < window_size; i++) {
        RMSx += pow(gyr_x_rad_s[i], 2);
        RMSx_array[i] = sqrt(RMSx/(i+1));
    }

    // the RMSy is calculated up to the i-th data and stored in the array
    for (int i = 0; i < window_size; i++) {
        RMSy += pow(gyr_y_rad_s[i], 2);
        RMSy_array[i] = sqrt(RMSy/(i+1));
    }

    // the RMSz is calculated up to the i-th data and stored in the array
    for (int i = 0; i < window_size; i++) {
        RMSz += pow(gyr_z_rad_s[i], 2);
        RMSz_array[i] = sqrt(RMSz/(i+1));
    }

    printf("Datos de RMS\n");

    // the RMSx data is printed
    for (int i = 0; i < window_size; i++) {
        printf("[Ang_Vel rad/s] Dato %d: RMSx: %f\n", i+1 , RMSx_array[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }

    // the RMSy data is printed
    for (int i = 0; i < window_size; i++) {
        printf("[Ang_Vel rad/s] Dato %d: RMSy: %f\n", i+1 , RMSy_array[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }

    // the RMSz data is printed
    for (int i = 0; i < window_size; i++) {
        printf("[Ang_Vel rad/s] Dato %d: RMSz: %f\n", i+1 , RMSz_array[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }

    printf("Fin de los datos de RMS\n");

    printf("Datos de los 5 valores mÃ¡s altos de RMS\n");

    // arrays are created with malloc to store the top 5 RMS data
    float *top_5_RMSx = (float *)malloc(5 * sizeof(float));
    float *top_5_RMSy = (float *)malloc(5 * sizeof(float));
    float *top_5_RMSz = (float *)malloc(5 * sizeof(float));

    printf("Calculando los 5 valores mÃ¡s altos de RMSx...\n");

    // the top 5 RMSx values are stored in the array
    save_top_5(RMSx_array, window_size, top_5_RMSx);

    // the data of the top_5_RMSx array is printed
    for (int i = 0; i < 5; i++) {
        printf("[Ang_Vel rad/s] Top %d: RMSx: %f\n", i+1 , top_5_RMSx[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }

    // the arrays are freed
    free(top_5_RMSx);
    free(RMSx_array);

    printf("Calculando los 5 valores mÃ¡s altos de RMSy...\n");

    // the top 5 RMSy values are stored in the array
    save_top_5(RMSy_array, window_size, top_5_RMSy);

    // the data of the top_5_RMSy array is printed
    for (int i = 0; i < 5; i++) {
        printf("[Ang_Vel rad/s] Top %d: RMSy: %f\n", i+1 , top_5_RMSy[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }

    // the arrays are freed
    free(top_5_RMSy);
    free(RMSy_array);

    printf("Calculando los 5 valores mÃ¡s altos de RMSz...\n");

    // the top 5 RMSz values are stored in the array
    save_top_5(RMSz_array, window_size, top_5_RMSz);

    // the data of the top_5_RMSz array is printed
    for (int i = 0; i < 5; i++) {
        printf("[Ang_Vel rad/s] Top %d: RMSz: %f\n", i+1 , top_5_RMSz[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }

    // the arrays are freed
    free(top_5_RMSz);
    free(RMSz_array);

    printf("Fin de los datos de los 5 valores mÃ¡s altos de RMS\n");

    printf("Datos de los 5 valores mÃ¡s altos de velocidad angular en rad/s\n");

    // arrays are created with malloc to store the top 5 gyr_x data
    float *top_5_gyr_x = (float *)malloc(5 * sizeof(float));
    float *top_5_gyr_y = (float *)malloc(5 * sizeof(float));
    float *top_5_gyr_z = (float *)malloc(5 * sizeof(float));

    printf("Calculando los 5 valores mÃ¡s altos de gyr_x...\n");

    // the top 5 gyr_x values are stored in the array
    save_top_5(gyr_x_rad_s, window_size, top_5_gyr_x);

    // the data of the top_5_gyr_x array is printed
    for (int i = 0; i < 5; i++) {
        printf("[Ang_Vel rad/s] Top %d: gyr_x: %f rad/s\n", i+1 , top_5_gyr_x[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }

    // the arrays are freed
    free(top_5_gyr_x);
    free(gyr_x_rad_s);

    printf("Calculando los 5 valores mÃ¡s altos de gyr_y...\n");

    // the top 5 gyr_y values are stored in the array
    save_top_5(gyr_y_rad_s, window_size, top_5_gyr_y);

    // the data of the top_5_gyr_y array is printed
    for (int i = 0; i < 5; i++) {
        printf("[Ang_Vel rad/s] Top %d: gyr_y: %f rad/s\n", i+1 , top_5_gyr_y[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }

    // the arrays are freed
    free(top_5_gyr_y);
    free(gyr_y_rad_s);

    printf("Calculando los 5 valores mÃ¡s altos de gyr_z...\n");

    // the top 5 gyr_z values are stored in the array
    save_top_5(gyr_z_rad_s, window_size, top_5_gyr_z);

    // the data of the top_5_gyr_z array is printed
    for (int i = 0; i < 5; i++) {
        printf("[Ang_Vel rad/s] Top %d: gyr_z: %f rad/s\n", i+1 , top_5_gyr_z[i]);
        vTaskDelay(delay_for_watchdog / portTICK_PERIOD_MS);
    }

    // the arrays are freed
    free(top_5_gyr_z);
    free(gyr_z_rad_s);

    printf("Fin de los datos de los 5 valores mÃ¡s altos de velocidad angular en rad/s\n");

    printf("Fin de los datos de velocidad angular en rad/s\n\n");
}

void bmi_lectura(int window_size, float to_m_s2_multiplier, float to_g_multiplier, float to_rad_s_multiplier, char powermode) {
    uint8_t reg_intstatus = 0x03, tmp;
    int bytes_data8 = 12;
    uint8_t reg_data = 0x0C, data_data8[bytes_data8];
    uint16_t acc_x, acc_y, acc_z, gyr_x, gyr_y, gyr_z;

    // se crean arrays con malloc para almacenar los window_size datos de aceleracion y giroscopio
    uint16_t *acc_x_array = (uint16_t *)malloc(window_size * sizeof(uint16_t));
    uint16_t *acc_y_array = (uint16_t *)malloc(window_size * sizeof(uint16_t));
    uint16_t *acc_z_array = (uint16_t *)malloc(window_size * sizeof(uint16_t));
    uint16_t *gyr_x_array = (uint16_t *)malloc(window_size * sizeof(uint16_t));
    uint16_t *gyr_y_array = (uint16_t *)malloc(window_size * sizeof(uint16_t));
    uint16_t *gyr_z_array = (uint16_t *)malloc(window_size * sizeof(uint16_t));
    
    int i = 0;

    printf("Comienza lectura\n\n");

    while (i < window_size) {

        bmi_i2c_read(I2C_NUM_0, &reg_intstatus, &tmp, 1);

        if ((tmp & 0b10000000) == 0x80) {
            ret = bmi_i2c_read(I2C_NUM_0, &reg_data, (uint8_t *)data_data8, bytes_data8);

            acc_x = ((uint16_t)data_data8[1] << 8) | (uint16_t)data_data8[0];
            acc_y = ((uint16_t)data_data8[3] << 8) | (uint16_t)data_data8[2];
            acc_z = ((uint16_t)data_data8[5] << 8) | (uint16_t)data_data8[4];

            gyr_x = ((uint16_t)data_data8[7] << 8) | (uint16_t)data_data8[6];
            gyr_y = ((uint16_t)data_data8[9] << 8) | (uint16_t)data_data8[8];
            gyr_z = ((uint16_t)data_data8[11] << 8) | (uint16_t)data_data8[10];

            if (ret != ESP_OK) {
                printf("Error lectura: %s \n", esp_err_to_name(ret));
            }
            // if the read was successful
            else {
                // the data is stored in the arrays
                acc_x_array[i] = acc_x;
                acc_y_array[i] = acc_y;
                acc_z_array[i] = acc_z;
                gyr_x_array[i] = gyr_x;
                gyr_y_array[i] = gyr_y;
                gyr_z_array[i] = gyr_z;

                // the data is printed
                printf("Lectura %d: acc_x: %f g     acc_y: %f g     acc_z: %f g     gyr_x: %f rad/s     gyr_y: %f rad/s      gyr_z: %f rad/s\n", i+1 , (int16_t)acc_x * to_g_multiplier, (int16_t)acc_y * to_g_multiplier, (int16_t)acc_z * to_g_multiplier, (int16_t)gyr_x * to_rad_s_multiplier, (int16_t)gyr_y * to_rad_s_multiplier, (int16_t)gyr_z * to_rad_s_multiplier);

                // the index is increased
                i += 1;
            }
        }
    }

    printf("Fin de la lectura\n\n");

    // the function that processes the acceleration data in m/s2 is called
    accel_m_s2_data(acc_x_array, acc_y_array, acc_z_array, window_size, to_m_s2_multiplier);

    // the function that processes the acceleration data in g is called
    accel_g_data(acc_x_array, acc_y_array, acc_z_array, window_size, to_g_multiplier);

    // if it's not in low power mode
    if (powermode != 'L') {
        // the function that processes the gyroscope data in rad/s is called
        ang_vel_rad_s_data(gyr_x_array, gyr_y_array, gyr_z_array, window_size, to_rad_s_multiplier);
    }
    
    // se liberan los arrays
    free(acc_x_array);
    free(acc_y_array);
    free(acc_z_array);
    free(gyr_x_array);
    free(gyr_y_array);
    free(gyr_z_array);

    printf("Procesamiento finalizado\n\n");
}

// this number is the denominator to get the multiplier for converting the data to m/s2, g and rad/s
// it's half of 2 to the power of 16 (because the data is 16 bits)
int bmi_denominator = 32768;

// function that sets and executes the lectura
void bmi_loop_lectura() {
    while (1) {

        // waiting for a BEGIN to initiate the reading, this begin includes the configuration of the reading
        char begin_with_config[22];
        printf("Esperando inicio de lectura\n");
        while (1) {
            int rLen = serial_read(begin_with_config, 22);
            if (rLen > 0) {
                // copy of the begin_with_config array only with the first 5 characters
                char begin[6];
                strncpy(begin, begin_with_config, 5);
                begin[5] = '\0';

                if (strcmp(begin, "BEGIN") == 0) {
                    printf("Inicio de lectura\n");
                    break;
                }
            }
        }

        // this array will hold the 3 chars that represent the numerical values given by the user
        char number_from_config[4];
        number_from_config[3] = '\0';
        
        // this is the power mode that the user wants to use
        // the power mode comes from the 5th char in begin_with_config
        char powermode = begin_with_config[5];
        
        // this is the index of the odr for the accelerometer that the user wants to use
        // the odr comes from the 6th to the 8th char in begin_with_config array
        for (int i = 0; i < 3; i++) {
            number_from_config[i] = begin_with_config[i + 6];
        }
        int acc_odr_index = atoi(number_from_config);

        // this is the index of the range for the accelerometer that the user wants to use
        // the range comes from the 9th to the 11th char in begin_with_config array
        for (int i = 0; i < 3; i++) {
            number_from_config[i] = begin_with_config[i + 9];
        }
        int acc_range_index = atoi(number_from_config);

        // this is the index of the odr for the gyroscope that the user wants to use
        // the odr comes from the 12th to the 14th char in begin_with_config array
        for (int i = 0; i < 3; i++) {
            number_from_config[i] = begin_with_config[i + 12];
        }
        int gyr_odr_index = atoi(number_from_config);

        // this is the index of the range for the gyroscope that the user wants to use
        // the range comes from the 15th to the 17th char in begin_with_config array
        for (int i = 0; i < 3; i++) {
            number_from_config[i] = begin_with_config[i + 15];
        }
        int gyr_range_index = atoi(number_from_config);

        // this is the number of readings that the user wants to take
        // the number comes from the 18th to the 20st char in begin_with_config array
        for (int i = 0; i < 3; i++) {
            number_from_config[i] = begin_with_config[i + 18];
        }
        int window_size = atoi(number_from_config);

        // this is the multiplier for converting the data to m/s2
        float to_m_s2_multiplier = (acc_range_values_m_s2[acc_range_index] / bmi_denominator);
        // this is the multiplier for converting the data to g
        float to_g_multiplier = (acc_range_values_g[acc_range_index] / bmi_denominator);
        // this is the multiplier for converting the data to rad/s
        float to_rad_s_multiplier = (gyr_range_values_rad_s[gyr_range_index] / bmi_denominator);


        if (powermode == 'S') {
            bmi_supend_mode();
        } else if (powermode == 'L') {
            bmi_low_power_mode(acc_odr_values[acc_odr_index], acc_range_values[acc_range_index]);
            bmi_internal_status();
            bmi_lectura(window_size, to_m_s2_multiplier, to_g_multiplier, to_rad_s_multiplier, powermode);
        } else if (powermode == 'N') {
            bmi_normal_power_mode(acc_odr_values[acc_odr_index], acc_range_values[acc_range_index], gyr_odr_values[gyr_odr_index], gyr_range_values[gyr_range_index]);
            bmi_internal_status();
            bmi_lectura(window_size, to_m_s2_multiplier, to_g_multiplier, to_rad_s_multiplier, powermode);
        } else if (powermode == 'P') {
            bmi_performance_power_mode(acc_odr_values[acc_odr_index], acc_range_values[acc_range_index], gyr_odr_values[gyr_odr_index], gyr_range_values[gyr_range_index]);
            bmi_internal_status();
            bmi_lectura(window_size, to_m_s2_multiplier, to_g_multiplier, to_rad_s_multiplier, powermode);
        } else {
            printf("Modo de consumo no vÃ¡lido\n");
        }
    }
}

// ------------ BME 688 ------------- //
uint8_t calc_gas_wait(uint16_t dur) {
    // Fuente: BME688 API
    // https://github.com/boschsensortec/BME68x_SensorAPI/blob/master/bme68x.c#L1176
    uint8_t factor = 0;
    uint8_t durval;

    if (dur >= 0xfc0) {
        durval = 0xff; /* Max duration*/
    } else {
        while (dur > 0x3F) {
            dur = dur >> 2;
            factor += 1;
        }

        durval = (uint8_t)(dur + (factor * 64));
    }

    return durval;
}

uint8_t calc_res_heat(uint16_t temp) {
    // Fuente: BME688 API
    // https://github.com/boschsensortec/BME68x_SensorAPI/blob/master/bme68x.c#L1145
    uint8_t heatr_res;
    uint8_t amb_temp = 25;

    uint8_t reg_par_g1 = 0xED;
    uint8_t par_g1;
    bme_i2c_read(I2C_NUM_0, &reg_par_g1, &par_g1, 1);

    uint8_t reg_par_g2_lsb = 0xEB;
    uint8_t par_g2_lsb;
    bme_i2c_read(I2C_NUM_0, &reg_par_g2_lsb, &par_g2_lsb, 1);
    uint8_t reg_par_g2_msb = 0xEC;
    uint8_t par_g2_msb;
    bme_i2c_read(I2C_NUM_0, &reg_par_g2_msb, &par_g2_msb, 1);
    uint16_t par_g2 = (int16_t)(CONCAT_BYTES(par_g2_msb, par_g2_lsb));

    uint8_t reg_par_g3 = 0xEE;
    uint8_t par_g3;
    bme_i2c_read(I2C_NUM_0, &reg_par_g3, &par_g3, 1);

    uint8_t reg_res_heat_range = 0x02;
    uint8_t res_heat_range;
    uint8_t mask_res_heat_range = (0x3 << 4);
    uint8_t tmp_res_heat_range;

    uint8_t reg_res_heat_val = 0x00;
    uint8_t res_heat_val;

    int32_t var1;
    int32_t var2;
    int32_t var3;
    int32_t var4;
    int32_t var5;
    int32_t heatr_res_x100;

    if (temp > 400) {
        temp = 400;
    }

    bme_i2c_read(I2C_NUM_0, &reg_res_heat_range, &tmp_res_heat_range, 1);
    bme_i2c_read(I2C_NUM_0, &reg_res_heat_val, &res_heat_val, 1);
    res_heat_range = (mask_res_heat_range & tmp_res_heat_range) >> 4;

    var1 = (((int32_t)amb_temp * par_g3) / 1000) * 256;
    var2 = (par_g1 + 784) * (((((par_g2 + 154009) * temp * 5) / 100) + 3276800) / 10);
    var3 = var1 + (var2 / 2);
    var4 = (var3 / (res_heat_range + 4));
    var5 = (131 * res_heat_val) + 65536;
    heatr_res_x100 = (int32_t)(((var4 / var5) - 250) * 34);
    heatr_res = (uint8_t)((heatr_res_x100 + 50) / 100);

    return heatr_res;
}

int bme_get_chipid(void) {
    uint8_t reg_id = 0xd0;
    uint8_t tmp;

    bme_i2c_read(I2C_NUM_0, &reg_id, &tmp, 1);
    printf("Valor de CHIPID: %2X \n\n", tmp);

    if (tmp == 0x61) {
        printf("Chip BME688 reconocido.\n\n");
        return 1;
    } else {
        printf("Chip BME688 no reconocido. \nCHIP ID: %2x\n\n", tmp);  // %2X
    }

    return 0;
}

int bme_softreset(void) {
    uint8_t reg_softreset = 0xE0, val_softreset = 0xB6;

    ret = bme_i2c_write(I2C_NUM_0, &reg_softreset, &val_softreset, 1);
    vTaskDelay(1000 / portTICK_PERIOD_MS);
    if (ret != ESP_OK) {
        printf("\nError en softreset: %s \n", esp_err_to_name(ret));
        return 1;
    } else {
        printf("\nSoftreset: OK\n\n");
    }
    return 0;
}

void bme_forced_mode(void) {
    /*
    Fuente: Datasheet[19]
    https://www.bosch-sensortec.com/media/boschsensortec/downloads/datasheets/bst-bme688-ds000.pdf#page=19

    Para configurar el BME688 en forced mode los pasos son:

    1. Set humidity oversampling to 1x     |-| 0b001 to osrs_h<2:0>
    2. Set temperature oversampling to 2x  |-| 0b010 to osrs_t<2:0>
    3. Set pressure oversampling to 16x    |-| 0b101 to osrs_p<2:0>

    4. Set gas duration to 100 ms          |-| 0x59 to gas_wait_0
    5. Set heater step size to 0           |-| 0x00 to res_heat_0
    6. Set number of conversion to 0       |-| 0b0000 to nb_conv<3:0> and enable gas measurements
    7. Set run_gas to 1                    |-| 0b1 to run_gas<5>

    8. Set operation mode                  |-| 0b01  to mode<1:0>

    */

    // Datasheet[33]
    uint8_t ctrl_hum = 0x72;
    uint8_t ctrl_meas = 0x74;
    uint8_t gas_wait_0 = 0x64;
    uint8_t res_heat_0 = 0x5A;
    uint8_t ctrl_gas_1 = 0x71;

    uint8_t mask;
    uint8_t prev;
    // Configuramos el oversampling (Datasheet[36])

    // 1. osrs_h esta en ctrl_hum (LSB) -> seteamos 001 en bits 2:0
    uint8_t osrs_h = 0b001;
    mask = 0b00000111;
    bme_i2c_read(I2C_NUM_0, &ctrl_hum, &prev, 1);
    osrs_h = (prev & ~mask) | osrs_h;

    // 2. osrs_t esta en ctrl_meas MSB -> seteamos 010 en bits 7:5
    uint8_t osrs_t = 0b01000000;
    // 3. osrs_p esta en ctrl_meas LSB -> seteamos 101 en bits 4:2 [Datasheet:37]
    uint8_t osrs_p = 0b00010100;
    uint8_t osrs_t_p = osrs_t | osrs_p;
    // Se recomienda escribir hum, temp y pres en un solo write

    // Configuramos el sensor de gas

    // 4. Seteamos gas_wait_0 a 100ms
    uint8_t gas_duration = calc_gas_wait(100);

    // 5. Seteamos res_heat_0
    uint8_t heater_step = calc_res_heat(300);

    // 6. nb_conv esta en ctrl_gas_1 -> seteamos bits 3:0
    uint8_t nb_conv = 0b00000000;
    // 7. run_gas esta en ctrl_gas_1 -> seteamos bit 5
    uint8_t run_gas = 0b00100000;
    uint8_t gas_conf = nb_conv | run_gas;

    bme_i2c_write(I2C_NUM_0, &ctrl_hum, &osrs_h, 1);
    bme_i2c_write(I2C_NUM_0, &ctrl_meas, &osrs_t_p, 1);
    bme_i2c_write(I2C_NUM_0, &gas_wait_0, &gas_duration, 1);
    bme_i2c_write(I2C_NUM_0, &res_heat_0, &heater_step, 1);
    bme_i2c_write(I2C_NUM_0, &ctrl_gas_1, &gas_conf, 1);

    // Seteamos el modo
    // 8. Seteamos el modo a 01, pasando primero por sleep
    uint8_t mode = 0b00000001;
    uint8_t tmp_pow_mode;
    uint8_t pow_mode = 0;

    do {
        ret = bme_i2c_read(I2C_NUM_0, &ctrl_meas, &tmp_pow_mode, 1);

        if (ret == ESP_OK) {
            // Se pone en sleep
            pow_mode = (tmp_pow_mode & 0x03);
            if (pow_mode != 0) {
                tmp_pow_mode &= ~0x03;
                ret = bme_i2c_write(I2C_NUM_0, &ctrl_meas, &tmp_pow_mode, 1);
            }
        }
    } while ((pow_mode != 0x0) && (ret == ESP_OK));

    tmp_pow_mode = (tmp_pow_mode & ~0x03) | mode;
    ret = bme_i2c_write(I2C_NUM_0, &ctrl_meas, &tmp_pow_mode, 1);
    vTaskDelay(pdMS_TO_TICKS(50));
}

int bme_check_forced_mode(void) {
    uint8_t ctrl_hum = 0x72;
    uint8_t ctrl_meas = 0x74;
    uint8_t gas_wait_0 = 0x64;
    uint8_t res_heat_0 = 0x5A;
    uint8_t ctrl_gas_1 = 0x71;

    uint8_t tmp, tmp2, tmp3, tmp4, tmp5;

    ret = bme_i2c_read(I2C_NUM_0, &ctrl_hum, &tmp, 1);
    ret = bme_i2c_read(I2C_NUM_0, &gas_wait_0, &tmp2, 1);
    ret = bme_i2c_read(I2C_NUM_0, &res_heat_0, &tmp3, 1);
    ret = bme_i2c_read(I2C_NUM_0, &ctrl_gas_1, &tmp4, 1);
    ret = bme_i2c_read(I2C_NUM_0, &ctrl_meas, &tmp5, 1);
    vTaskDelay(task_delay_ms / portTICK_PERIOD_MS);
    return (tmp == 0b001 && tmp2 == 0x59 && tmp3 == 0x00 && tmp4 == 0b100000 && tmp5 == 0b01010101);
}

uint32_t read_temp_data() {
    uint8_t tmp;

    // Se obtienen los datos de temperatura
    uint8_t forced_temp_addr[] = {0x22, 0x23, 0x24};
    uint32_t temp_adc = 0;
    // Datasheet[41]
    // https://www.bosch-sensortec.com/media/boschsensortec/downloads/datasheets/bst-bme688-ds000.pdf#page=41

    bme_i2c_read(I2C_NUM_0, &forced_temp_addr[0], &tmp, 1);
    temp_adc = temp_adc | tmp << 12;
    bme_i2c_read(I2C_NUM_0, &forced_temp_addr[1], &tmp, 1);
    temp_adc = temp_adc | tmp << 4;
    bme_i2c_read(I2C_NUM_0, &forced_temp_addr[2], &tmp, 1);
    temp_adc = temp_adc | (tmp & 0xf0) >> 4;

    return temp_adc;
}

int* bme_temp_celsius(uint32_t temp_adc) {
    // Datasheet[23]
    // https://www.bosch-sensortec.com/media/boschsensortec/downloads/datasheets/bst-bme688-ds000.pdf#page=23

    // Se obtienen los parametros de calibracion
    uint8_t addr_par_t1_lsb = 0xE9, addr_par_t1_msb = 0xEA;
    uint8_t addr_par_t2_lsb = 0x8A, addr_par_t2_msb = 0x8B;
    uint8_t addr_par_t3_lsb = 0x8C;
    uint16_t par_t1;
    uint16_t par_t2;
    uint16_t par_t3;

    uint8_t par[5];
    bme_i2c_read(I2C_NUM_0, &addr_par_t1_lsb, par, 1);
    bme_i2c_read(I2C_NUM_0, &addr_par_t1_msb, par + 1, 1);
    bme_i2c_read(I2C_NUM_0, &addr_par_t2_lsb, par + 2, 1);
    bme_i2c_read(I2C_NUM_0, &addr_par_t2_msb, par + 3, 1);
    bme_i2c_read(I2C_NUM_0, &addr_par_t3_lsb, par + 4, 1);

    par_t1 = (par[1] << 8) | par[0];
    par_t2 = (par[3] << 8) | par[2];
    par_t3 = par[4];

    int64_t var1;
    int64_t var2;
    int64_t var3;
    int t_fine;
    int temp_comp;

    var1 = ((int32_t)temp_adc >> 3) - ((int32_t)par_t1 << 1);
    var2 = (var1 * (int32_t)par_t2) >> 11;
    var3 = ((((var1 >> 1) * (var1 >> 1)) >> 12) * ((int32_t)par_t3 << 4)) >> 14;
    t_fine = var2 + var3;
    temp_comp = ((t_fine * 5) + 128) >> 8;

    static int arr[2];
    arr[0] = temp_comp;
    arr[1] = t_fine;
    return arr;
}

uint32_t read_pressure_data() {
    uint8_t tmp;

    // Se obtienen los datos de presion
    uint8_t forced_press_addr[] = {0x1F, 0x20, 0x21};
    uint32_t press_adc = 0;
    // Datasheet[41]
    // https://www.bosch-sensortec.com/media/boschsensortec/downloads/datasheets/bst-bme688-ds000.pdf#page=41

    bme_i2c_read(I2C_NUM_0, &forced_press_addr[0], &tmp, 1);
    press_adc = press_adc | tmp << 12;
    bme_i2c_read(I2C_NUM_0, &forced_press_addr[1], &tmp, 1);
    press_adc = press_adc | tmp << 4;
    bme_i2c_read(I2C_NUM_0, &forced_press_addr[2], &tmp, 1);
    press_adc = press_adc | (tmp & 0xf0) >> 4;

    return press_adc;
}

int bme_pressure_pascal(uint32_t press_adc, int t_fine) {
    // Datasheet[24]
    // https://www.bosch-sensortec.com/media/boschsensortec/downloads/datasheets/bst-bme688-ds000.pdf#page=23

    // Se obtienen los parametros de calibracion
    uint8_t addr_par_p1_lsb = 0x8E, addr_par_p1_msb = 0x8F;
    uint8_t addr_par_p2_lsb = 0x90, addr_par_p2_msb = 0x91;
    uint8_t addr_par_p3_lsb = 0x92;
    uint8_t addr_par_p4_lsb = 0x94, addr_par_p4_msb = 0x95;
    uint8_t addr_par_p5_lsb = 0x96, addr_par_p5_msb = 0x97;
    uint8_t addr_par_p6_lsb = 0x99;
    uint8_t addr_par_p7_lsb = 0x98;
    uint8_t addr_par_p8_lsb = 0x9C, addr_par_p8_msb = 0x9D;
    uint8_t addr_par_p9_lsb = 0x9E, addr_par_p9_msb = 0x9F;
    uint8_t addr_par_p10_lsb = 0xA0;
    uint16_t par_p1;
    uint16_t par_p2;
    uint16_t par_p3;
    uint16_t par_p4;
    uint16_t par_p5;
    uint16_t par_p6;
    uint16_t par_p7;
    uint16_t par_p8;
    uint16_t par_p9;
    uint16_t par_p10;

    uint8_t par[16];
    bme_i2c_read(I2C_NUM_0, &addr_par_p1_lsb, par, 1);
    bme_i2c_read(I2C_NUM_0, &addr_par_p1_msb, par + 1, 1);
    bme_i2c_read(I2C_NUM_0, &addr_par_p2_lsb, par + 2, 1);
    bme_i2c_read(I2C_NUM_0, &addr_par_p2_msb, par + 3, 1);
    bme_i2c_read(I2C_NUM_0, &addr_par_p3_lsb, par + 4, 1);
    bme_i2c_read(I2C_NUM_0, &addr_par_p4_lsb, par + 5, 1);
    bme_i2c_read(I2C_NUM_0, &addr_par_p4_msb, par + 6, 1);
    bme_i2c_read(I2C_NUM_0, &addr_par_p5_lsb, par + 7, 1);
    bme_i2c_read(I2C_NUM_0, &addr_par_p5_msb, par + 8, 1);
    bme_i2c_read(I2C_NUM_0, &addr_par_p6_lsb, par + 9, 1);  
    bme_i2c_read(I2C_NUM_0, &addr_par_p7_lsb, par + 10, 1);
    bme_i2c_read(I2C_NUM_0, &addr_par_p8_lsb, par + 11, 1);
    bme_i2c_read(I2C_NUM_0, &addr_par_p8_msb, par + 12, 1);
    bme_i2c_read(I2C_NUM_0, &addr_par_p9_lsb, par + 13, 1);
    bme_i2c_read(I2C_NUM_0, &addr_par_p9_msb, par + 14, 1);
    bme_i2c_read(I2C_NUM_0, &addr_par_p10_lsb, par + 15, 1);

    par_p1 = (par[1] << 8) | par[0];
    par_p2 = (par[3] << 8) | par[2];
    par_p3 = par[4];
    par_p4 = (par[6] << 8) | par[5];
    par_p5 = (par[8] << 8) | par[7];
    par_p6 = par[9];
    par_p7 = par[10];
    par_p8 = (par[12] << 8) | par[11];
    par_p9 = (par[14] << 8) | par[13];
    par_p10 = par[15];

    int64_t var1;
    int64_t var2;
    int64_t var3;
    int press_comp;

    var1 = ((int32_t)t_fine >> 1) - 64000;
    var2 = ((((var1 >> 2) * (var1 >> 2)) >> 11) * (int32_t)par_p6) >> 2;
    var2 = var2 + ((var1 * (int32_t)par_p5) << 1);
    var2 = (var2 >> 2) + ((int32_t)par_p4 << 16);
    var1 = (((((var1 >> 2) * (var1 >> 2)) >> 13) *
                ((int32_t)par_p3 << 5)) >> 3) + (((int32_t)par_p2 * var1) >> 1);
    var1 = var1 >> 18;
    var1 = ((32768 + var1) * (int32_t)par_p1) >> 15;
    press_comp = 1048576 - press_adc;
    press_comp = (uint32_t)((press_comp - (var2 >> 12)) * ((uint32_t)3125));
    if (press_comp >= (1 << 30))
        press_comp = ((press_comp / (uint32_t)var1) << 1);
    else
        press_comp = ((press_comp << 1) / (uint32_t)var1);
    var1 = ((int32_t)par_p9 * (int32_t)(((press_comp >> 3) *
                (press_comp >> 3)) >> 13)) >> 12;
    var2 = ((int32_t)(press_comp >> 2) * (int32_t)par_p8) >> 13;
    var3 = ((int32_t)(press_comp >> 8) * (int32_t)(press_comp >> 8) *
                (int32_t)(press_comp >> 8) * (int32_t)par_p10) >> 17;
    press_comp = (int32_t)(press_comp) +
                ((var1 + var2 + var3 + ((int32_t)par_p7 << 7)) >> 4);
    
    return press_comp;
}

uint32_t read_humidity_data() {
    uint8_t tmp;

    // Se obtienen los datos de humedad
    uint8_t forced_hum_addr[] = {0x25, 0x26};
    uint32_t hum_adc = 0;
    // Datasheet[41]
    // https://www.bosch-sensortec.com/media/boschsensortec/downloads/datasheets/bst-bme688-ds000.pdf#page=41

    bme_i2c_read(I2C_NUM_0, &forced_hum_addr[0], &tmp, 1);
    hum_adc = hum_adc | tmp << 8;
    bme_i2c_read(I2C_NUM_0, &forced_hum_addr[1], &tmp, 1);
    hum_adc = hum_adc | tmp;

    return hum_adc;
}

int bme_humidity_percent(uint32_t hum_adc, int temp_comp) {
    // Datasheet[26]
    // https://www.bosch-sensortec.com/media/boschsensortec/downloads/datasheets/bst-bme688-ds000.pdf#page=26

    // Se obtienen los parametros de calibracion
    uint8_t addr_par_h1_lsb = 0xE2, addr_par_h1_msb = 0xE3;
    uint8_t addr_par_h2_lsb = 0xE2, addr_par_h2_msb = 0xE1;
    uint8_t addr_par_h3_lsb = 0xE4;
    uint8_t addr_par_h4_lsb = 0xE5;
    uint8_t addr_par_h5_lsb = 0xE6;
    uint8_t addr_par_h6_lsb = 0xE7;
    uint8_t addr_par_h7_lsb = 0xE8;
    uint16_t par_h1;
    uint16_t par_h2;
    uint16_t par_h3;
    uint16_t par_h4;
    uint16_t par_h5;
    uint16_t par_h6;
    uint16_t par_h7;

    uint8_t par[9];
    bme_i2c_read(I2C_NUM_0, &addr_par_h1_lsb, par, 1);
    bme_i2c_read(I2C_NUM_0, &addr_par_h1_msb, par + 1, 1);
    par[2] = par[0];
    bme_i2c_read(I2C_NUM_0, &addr_par_h2_msb, par + 3, 1);
    bme_i2c_read(I2C_NUM_0, &addr_par_h3_lsb, par + 4, 1);
    bme_i2c_read(I2C_NUM_0, &addr_par_h4_lsb, par + 5, 1);
    bme_i2c_read(I2C_NUM_0, &addr_par_h5_lsb, par + 6, 1);
    bme_i2c_read(I2C_NUM_0, &addr_par_h6_lsb, par + 7, 1);
    bme_i2c_read(I2C_NUM_0, &addr_par_h7_lsb, par + 8, 1);

    par_h1 = (par[1] << 4) | (par[0] & 0x0f);
    par_h2 = (par[3] << 4) | ((par[2] & 0xf0) >> 4);
    par_h3 = par[4];
    par_h4 = par[5];
    par_h5 = par[6];
    par_h6 = par[7];
    par_h7 = par[8];

    int64_t var1;
    int64_t var2;
    int64_t var3;
    int64_t var4;
    int64_t var5;
    int64_t var6;
    int temp_scaled;
    int hum_comp;

    temp_scaled = (int32_t)temp_comp;
    var1 = (int32_t)hum_adc - (int32_t)((int32_t)par_h1 << 4) -
            (((temp_scaled * (int32_t)par_h3) / ((int32_t)100)) >> 1);
    var2 = ((int32_t)par_h2 * (((temp_scaled *
            (int32_t)par_h4) / ((int32_t)100)) +
            (((temp_scaled * ((temp_scaled * (int32_t)par_h5) /
            ((int32_t)100))) >> 6) / ((int32_t)100)) + ((int32_t)(1 << 14)))) >> 10;
    var3 = var1 * var2;
    var4 = (((int32_t)par_h6 << 7) +
            ((temp_scaled * (int32_t)par_h7) / ((int32_t)100))) >> 4;
    var5 = ((var3 >> 14) * (var3 >> 14)) >> 10;
    var6 = (var4 * var5) >> 1;
    hum_comp = (var3 + var6) >> 12;
    hum_comp = (((var3 + var6) >> 10) * ((int32_t) 1000)) >> 12;    

    return hum_comp;
}

uint16_t read_gas_resistance_data() {
    uint8_t tmp;

    // Se obtienen los datos de resistencia de gas
    uint8_t forced_gas_addr[] = {0x2C, 0x2D};
    uint16_t gas_res_adc = 0;
    // Datasheet[41]
    // https://www.bosch-sensortec.com/media/boschsensortec/downloads/datasheets/bst-bme688-ds000.pdf#page=41

    bme_i2c_read(I2C_NUM_0, &forced_gas_addr[0], &tmp, 1);
    gas_res_adc = gas_res_adc | tmp << 2;
    bme_i2c_read(I2C_NUM_0, &forced_gas_addr[1], &tmp, 1);
    gas_res_adc = gas_res_adc | (tmp & 0xc0) >> 6;

    return gas_res_adc;
}

void bme_get_mode(void) {
    uint8_t reg_mode = 0x74;
    uint8_t tmp;

    ret = bme_i2c_read(I2C_NUM_0, &reg_mode, &tmp, 1);

    tmp = tmp & 0x3;

    printf("Valor de BME MODE: %2X \n\n", tmp);
}

void bme_read_data(void) {
    // Datasheet[23:41]
    // https://www.bosch-sensortec.com/media/boschsensortec/downloads/datasheets/bst-bme688-ds000.pdf#page=23

    for (;;) {
        bme_forced_mode();
        uint32_t temp_adc = read_temp_data();
        int* pair = bme_temp_celsius(temp_adc);

        uint32_t temp = pair[0];
        uint32_t press_adc = read_pressure_data();
        uint32_t press = bme_pressure_pascal(press_adc, pair[1]);
        uint32_t hum_adc = read_humidity_data();
        uint32_t hum = bme_humidity_percent(hum_adc, pair[0]);

        printf("Temperatura: %f, PresiÃ³n: %d, Humedad: %f%%\n", (float)temp / 100, (int)press, (float)hum/1000);

    }
}

void app_main(void) {
    ESP_ERROR_CHECK(sensor_init());

    if (bmi_get_chipid()) {
        // ------------ BMI 270 ------------- //
        bmi_softreset();
        bmi_initialization();
        bmi_check_initialization();
        uart_setup();
        printf("\n");
        srand(time(0));
        bmi_loop_lectura();
    }
    else if (bme_get_chipid()) {
        // ------------ BME 688 ------------- //
        bme_softreset();
        bme_get_mode();
        bme_forced_mode();
        printf("Comienza lectura\n\n");
        bme_read_data();
    } else {
        printf("No se reconoce ningÃºn chip.\n\n");
    }
}